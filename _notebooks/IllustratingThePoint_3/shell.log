2019-03-09 14:39:49 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2019-03-09 14:39:49 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-03-09 14:39:49 - For help type #help;;
2019-03-09 14:39:49 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2019-03-09 14:39:49 -   seq []
2019-03-09 14:39:49 - --> Added 'D:\Applications\IfSharp.v3.0.0' to library include path
2019-03-09 14:39:49 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-03-09 14:39:49 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\NetMQ.dll' (file may be locked by F# Interactive process)
2019-03-11 19:47:47 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2019-03-11 19:47:47 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-03-11 19:47:47 - For help type #help;;
2019-03-11 19:47:47 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2019-03-11 19:47:47 -   seq []
2019-03-11 19:47:47 - --> Added 'D:\Applications\IfSharp.v3.0.0' to library include path
2019-03-11 19:47:47 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-03-11 19:47:47 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\NetMQ.dll' (file may be locked by F# Interactive process)
2019-03-11 20:01:31 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2019-03-11 20:01:31 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-03-11 20:01:31 - For help type #help;;
2019-03-11 20:01:31 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2019-03-11 20:01:31 -   seq []
2019-03-11 20:01:31 - --> Added 'D:\Applications\IfSharp.v3.0.0' to library include path
2019-03-11 20:01:31 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-03-11 20:01:31 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\NetMQ.dll' (file may be locked by F# Interactive process)
2019-03-19 22:37:24 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2019-03-19 22:37:24 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-03-19 22:37:24 - For help type #help;;
2019-03-19 22:37:24 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2019-03-19 22:37:24 -   seq []
2019-03-19 22:37:24 - --> Added 'D:\Applications\IfSharp.v3.0.0' to library include path
2019-03-19 22:37:24 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-03-19 22:37:24 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\NetMQ.dll' (file may be locked by F# Interactive process)
2019-03-19 22:44:39 - #r @"..\packages\XPlot.Plotly.1.4.2\lib\net45\XPlot.Plotly.dll"
2019-03-19 22:44:39 - #r @"..\packages\\MathNet.Numerics.3.17.0\lib\net40\MathNet.Numerics.dll"
2019-03-19 22:44:39 - #r @"..\packages\\MathNet.Numerics.FSharp.3.17.0\lib\net40\MathNet.Numerics.FSharp.dll"
2019-03-19 22:44:39 - Assembly reference '..\packages\XPlot.Plotly.1.4.2\lib\net45\XPlot.Plotly.dll' was not found or is invalid
2019-03-19 22:45:02 - #r @".\XPlot.Plotly.1.4.2\lib\net45\XPlot.Plotly.dll"
2019-03-19 22:45:02 - #r @".\MathNet.Numerics.3.17.0\lib\net40\MathNet.Numerics.dll"
2019-03-19 22:45:02 - #r @".\MathNet.Numerics.FSharp.3.17.0\lib\net40\MathNet.Numerics.FSharp.dll"
2019-03-19 22:45:03 - Assembly reference '.\XPlot.Plotly.1.4.2\lib\net45\XPlot.Plotly.dll' was not found or is invalid
2019-03-19 22:45:27 - #r @".\XPlot.Plotly.dll"
2019-03-19 22:45:27 - #r @".\MathNet.Numerics.dll"
2019-03-19 22:45:27 - #r @".\MathNet.Numerics.FSharp.dll"
2019-03-19 22:45:37 - #load ".\DataAccess.fs"
2019-03-19 22:45:37 - #load ".\Statistics.fs"
2019-03-19 22:45:37 - #load ".\PGraphs.fs"
2019-03-19 22:45:37 - #load ".\Analyses.fs"
2019-03-19 22:46:24 - open System
2019-03-19 22:46:24 - open System.Linq
2019-03-19 22:46:24 - open HousePriceAnalysis
2019-03-19 22:46:24 - open Statistics
2019-03-19 22:46:24 - open DataSet
2019-03-19 22:46:24 - open PGraphs
2019-03-19 22:46:53 - //DISTRIBUTION
2019-03-19 22:46:53 - let year=2016
2019-03-19 22:46:53 - let dataSet = SomeTransactions(fun h -> h.Date.Year=year) |> Seq.map (fun (p,h) -> (p.Eastings, p.Northings, h.Price) )
2019-03-19 22:46:53 - PGraphs.HeatMap(String.Format("House Prices in the UK - {0}",year))("East")("North")(dataSet)
2019-03-19 22:51:31 - #load ".\DataAccess.fs"
2019-03-19 22:51:31 - #load ".\Statistics.fs"
2019-03-19 22:51:31 - #load ".\PGraphs.fs"
2019-03-19 22:51:31 - #load ".\Analyses.fs"
2019-03-19 22:51:32 - This expression was expected to have type
2019-03-19 22:51:32 -     'int'    
2019-03-19 22:51:32 - but here has type
2019-03-19 22:51:32 -     ''a * 'b'    
2019-03-19 22:51:32 - Type mismatch. Expecting a
2019-03-19 22:51:32 -     'seq<(int -> seq<float> -> float)> -> float []'    
2019-03-19 22:51:32 - but given a
2019-03-19 22:51:32 -     'seq<(int -> seq<float> -> float)> -> (int -> seq<float> -> float) []'    
2019-03-19 22:51:32 - The type 'float' does not match the type 'int -> seq<float> -> float'
2019-03-19 22:51:32 - This expression was expected to have type
2019-03-19 22:51:32 -     'int'    
2019-03-19 22:51:32 - but here has type
2019-03-19 22:51:32 -     ''a * 'b'    
2019-03-19 22:51:32 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-19 22:51:32 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-19 22:51:57 - #load ".\DataAccess.fs"
2019-03-19 22:51:57 - #load ".\Statistics.fs"
2019-03-19 22:51:57 - #load ".\PGraphs.fs"
2019-03-19 22:51:57 - #load ".\Analyses.fs"
2019-03-19 22:51:58 - This expression was expected to have type
2019-03-19 22:51:58 -     'int'    
2019-03-19 22:51:58 - but here has type
2019-03-19 22:51:58 -     ''a * 'b'    
2019-03-19 22:51:58 - Type mismatch. Expecting a
2019-03-19 22:51:58 -     'seq<(int -> seq<float> -> float)> -> float []'    
2019-03-19 22:51:58 - but given a
2019-03-19 22:51:58 -     'seq<(int -> seq<float> -> float)> -> (int -> seq<float> -> float) []'    
2019-03-19 22:51:58 - The type 'float' does not match the type 'int -> seq<float> -> float'
2019-03-19 22:51:58 - This expression was expected to have type
2019-03-19 22:51:58 -     'int'    
2019-03-19 22:51:58 - but here has type
2019-03-19 22:51:58 -     ''a * 'b'    
2019-03-19 22:51:58 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-19 22:51:58 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-19 22:52:43 - #load ".\DataAccess.fs"
2019-03-19 22:52:43 - #load ".\Statistics.fs"
2019-03-19 22:52:43 - #load ".\PGraphs.fs"
2019-03-19 22:52:43 - #load ".\Analyses.fs"
2019-03-19 22:52:45 - This expression was expected to have type
2019-03-19 22:52:45 -     'int'    
2019-03-19 22:52:45 - but here has type
2019-03-19 22:52:45 -     ''a * 'b'    
2019-03-19 22:52:45 - Type mismatch. Expecting a
2019-03-19 22:52:45 -     'seq<(int -> seq<float> -> float)> -> float []'    
2019-03-19 22:52:45 - but given a
2019-03-19 22:52:45 -     'seq<(int -> seq<float> -> float)> -> (int -> seq<float> -> float) []'    
2019-03-19 22:52:45 - The type 'float' does not match the type 'int -> seq<float> -> float'
2019-03-19 22:52:45 - This expression was expected to have type
2019-03-19 22:52:45 -     'int'    
2019-03-19 22:52:45 - but here has type
2019-03-19 22:52:45 -     ''a * 'b'    
2019-03-19 22:52:45 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-19 22:52:45 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-19 22:55:03 - #load ".\DataAccess.fs"
2019-03-19 22:55:03 - #load ".\Statistics.fs"
2019-03-19 22:55:03 - #load ".\PGraphs.fs"
2019-03-19 22:55:03 - #load ".\Analyses.fs"
2019-03-19 22:55:03 - This expression was expected to have type
2019-03-19 22:55:03 -     'int'    
2019-03-19 22:55:03 - but here has type
2019-03-19 22:55:03 -     ''a * 'b'    
2019-03-19 22:55:03 - Type mismatch. Expecting a
2019-03-19 22:55:03 -     'seq<(int -> seq<float> -> float)> -> float []'    
2019-03-19 22:55:03 - but given a
2019-03-19 22:55:03 -     'seq<(int -> seq<float> -> float)> -> (int -> seq<float> -> float) []'    
2019-03-19 22:55:03 - The type 'float' does not match the type 'int -> seq<float> -> float'
2019-03-19 22:55:03 - This expression was expected to have type
2019-03-19 22:55:03 -     'int'    
2019-03-19 22:55:03 - but here has type
2019-03-19 22:55:03 -     ''a * 'b'    
2019-03-19 22:55:03 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-19 22:55:03 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-19 22:55:20 - shutdown request
2019-03-19 22:55:39 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2019-03-19 22:55:39 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-03-19 22:55:39 - For help type #help;;
2019-03-19 22:55:39 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2019-03-19 22:55:39 -   seq []
2019-03-19 22:55:39 - --> Added 'D:\Applications\IfSharp.v3.0.0' to library include path
2019-03-19 22:55:39 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-03-19 22:55:39 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\NetMQ.dll' (file may be locked by F# Interactive process)
2019-03-19 22:57:02 - shutdown request
2019-03-19 22:59:51 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2019-03-19 22:59:51 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-03-19 22:59:51 - For help type #help;;
2019-03-19 22:59:51 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2019-03-19 22:59:51 -   seq []
2019-03-19 22:59:51 - --> Added 'D:\Applications\IfSharp.v3.0.0' to library include path
2019-03-19 22:59:51 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-03-19 22:59:51 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\NetMQ.dll' (file may be locked by F# Interactive process)
2019-03-19 22:59:51 - #load "Paket.fsx"
2019-03-19 22:59:51 - Paket.Package [
2019-03-19 22:59:51 -     "MathNet.Numerics"
2019-03-19 22:59:51 -     "MathNet.Numerics.FSharp"
2019-03-19 22:59:51 -     "XPlot.Plotly"
2019-03-19 22:59:51 -     ]
2019-03-19 22:59:51 - #load "Paket.Generated.Refs.fsx"
2019-03-19 23:00:38 - #load ".\DataAccess.fs"
2019-03-19 23:00:38 - #load ".\Statistics.fs"
2019-03-19 23:00:38 - #load ".\PGraphs.fs"
2019-03-19 23:00:38 - #load ".\Analyses.fs"
2019-03-19 23:00:55 - open System
2019-03-19 23:00:55 - open System.Linq
2019-03-19 23:00:55 - open HousePriceAnalysis
2019-03-19 23:00:55 - open Statistics
2019-03-19 23:00:55 - open DataSet
2019-03-19 23:00:55 - open PGraphs
2019-03-19 23:00:59 - //DISTRIBUTION
2019-03-19 23:00:59 - let year=2016
2019-03-19 23:00:59 - let dataSet = SomeTransactions(fun h -> h.Date.Year=year) |> Seq.map (fun (p,h) -> (p.Eastings, p.Northings, h.Price) )
2019-03-19 23:00:59 - PGraphs.HeatMap(String.Format("House Prices in the UK - {0}",year))("East")("North")(dataSet)
2019-03-19 23:01:22 - let HeatMapAnalysis(filter:HousePriceReader.HousePriceInfo -> bool)(mapBox:float) =
2019-03-19 23:01:22 -     let y = SomeTransactions(filter)
2019-03-19 23:01:22 -     let dataSet = y |> Seq.map (fun (p,h) -> (p.Eastings, p.Northings, h.Price) )
2019-03-19 23:01:22 -     printfn "Total distributions %A" (dataSet.Count())
2019-03-19 23:01:22 -     let quantileDataSet = dataSet |> CollateBy(fun (x,y,v) -> (Math.Round(x/mapBox,0)*mapBox,Math.Round(y/mapBox,0)*mapBox))(QuantileBy(fun (x,y,v) -> v)(2)(4))
2019-03-19 23:01:22 -     printfn "Geographic distributions %A" (quantileDataSet.Count())
2019-03-19 23:01:22 -     HeatMap("Median House Prices in the UK")("East")("North")(quantileDataSet.Select(fun((x,y),v)->(x,y,v)))
2019-03-19 23:01:25 - //HeatMapAnalysis(fun h -> h.Date.Year=2016 && h.TownCity.ToLower()="london")(500.0)
2019-03-19 23:01:25 - HeatMapAnalysis(fun h -> h.Date.Year=2016)(5000.0)
2019-03-19 23:02:29 - ////NATIONAL DISTRIBUTION OF MEDIAN HOUSE PRICES
2019-03-19 23:02:29 - Analyses.ShowHousePriceMap(1)(4)(5000.0)(fun h -> h.Date.Year=2016)
2019-03-19 23:02:48 - Analyses.ShowHousePriceMap(2)(4)(5000.0)(fun h -> h.Date.Year=2016)
2019-03-19 23:02:50 - Analyses.ShowHousePriceMap(3)(4)(5000.0)(fun h -> h.Date.Year=2016)
2019-03-19 23:02:53 - Analyses.ShowHousePriceMap(4)(4)(5000.0)(fun h -> h.Date.Year=2016)
2019-03-19 23:06:33 - #load ".\DataAccess.fs"
2019-03-19 23:06:33 - #load ".\Statistics.fs"
2019-03-19 23:06:33 - #load ".\PGraphs.fs"
2019-03-19 23:06:33 - #load ".\Analyses.fs"
2019-03-19 23:06:33 - This expression was expected to have type
2019-03-19 23:06:33 -     'int'    
2019-03-19 23:06:33 - but here has type
2019-03-19 23:06:33 -     ''a * 'b'    
2019-03-19 23:06:33 - Type mismatch. Expecting a
2019-03-19 23:06:33 -     'seq<(int -> seq<float> -> float)> -> float []'    
2019-03-19 23:06:33 - but given a
2019-03-19 23:06:33 -     'seq<(int -> seq<float> -> float)> -> (int -> seq<float> -> float) []'    
2019-03-19 23:06:33 - The type 'float' does not match the type 'int -> seq<float> -> float'
2019-03-19 23:06:33 - This expression was expected to have type
2019-03-19 23:06:33 -     'int'    
2019-03-19 23:06:33 - but here has type
2019-03-19 23:06:33 -     ''a * 'b'    
2019-03-19 23:06:33 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-19 23:06:33 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-19 23:06:43 - shutdown request
2019-03-19 23:07:07 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2019-03-19 23:07:07 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-03-19 23:07:07 - For help type #help;;
2019-03-19 23:07:07 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2019-03-19 23:07:07 -   seq []
2019-03-19 23:07:07 - --> Added 'D:\Applications\IfSharp.v3.0.0' to library include path
2019-03-19 23:07:07 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-03-19 23:07:07 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\NetMQ.dll' (file may be locked by F# Interactive process)
2019-03-19 23:07:51 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2019-03-19 23:07:51 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-03-19 23:07:51 - For help type #help;;
2019-03-19 23:07:51 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2019-03-19 23:07:51 -   seq []
2019-03-19 23:07:51 - --> Added 'D:\Applications\IfSharp.v3.0.0' to library include path
2019-03-19 23:07:51 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-03-19 23:07:51 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\NetMQ.dll' (file may be locked by F# Interactive process)
2019-03-19 23:07:52 - #load "Paket.fsx"
2019-03-19 23:07:52 - Paket.Package [
2019-03-19 23:07:52 -     "MathNet.Numerics"
2019-03-19 23:07:52 -     "MathNet.Numerics.FSharp"
2019-03-19 23:07:52 -     "XPlot.Plotly"
2019-03-19 23:07:52 -     ]
2019-03-19 23:07:52 - #load "Paket.Generated.Refs.fsx"
2019-03-19 23:08:06 - #load ".\DataAccess.fs"
2019-03-19 23:08:06 - #load ".\Statistics.fs"
2019-03-19 23:08:06 - #load ".\PGraphs.fs"
2019-03-19 23:08:06 - #load ".\Analyses.fs"
2019-03-19 23:08:11 - No overloads match for method 'Scatter'. The available overloads are shown below.
2019-03-19 23:08:11 - Possible overload: 'static member Chart.Scatter : data:seq<#value> -> PlotlyChart'. Type constraint mismatch. The type 
2019-03-19 23:08:11 -     'Scattergl * Layout'    
2019-03-19 23:08:11 - is not compatible with type
2019-03-19 23:08:11 -     'seq<'a>'    
2019-03-19 23:08:11 - .
2019-03-19 23:08:11 - Possible overload: 'static member Chart.Scatter : data:seq<#key * #value> -> PlotlyChart'. Type constraint mismatch. The type 
2019-03-19 23:08:11 -     'Scattergl * Layout'    
2019-03-19 23:08:11 - is not compatible with type
2019-03-19 23:08:11 -     'seq<'a * 'b>'    
2019-03-19 23:08:11 - .
2019-03-19 23:08:11 - Possible overload: 'static member Chart.Scatter : data:seq<#seq<'a1 * 'a2>> -> PlotlyChart when 'a1 :> key and 'a2 :> value'. Type constraint mismatch. The type 
2019-03-19 23:08:11 -     'Scattergl * Layout'    
2019-03-19 23:08:11 - is not compatible with type
2019-03-19 23:08:11 -     'seq<'a>'    
2019-03-19 23:08:11 - .
2019-03-19 23:08:48 - #load ".\DataAccess.fs"
2019-03-19 23:08:48 - #load ".\Statistics.fs"
2019-03-19 23:08:48 - #load ".\PGraphs.fs"
2019-03-19 23:08:48 - #load ".\Analyses.fs"
2019-03-19 23:08:59 - open System
2019-03-19 23:08:59 - open System.Linq
2019-03-19 23:08:59 - open HousePriceAnalysis
2019-03-19 23:08:59 - open Statistics
2019-03-19 23:08:59 - open DataSet
2019-03-19 23:08:59 - open PGraphs
2019-03-19 23:09:05 - //DISTRIBUTION
2019-03-19 23:09:05 - let year=2016
2019-03-19 23:09:05 - let dataSet = SomeTransactions(fun h -> h.Date.Year=year) |> Seq.map (fun (p,h) -> (p.Eastings, p.Northings, h.Price) )
2019-03-19 23:09:05 - PGraphs.HeatMap(String.Format("House Prices in the UK - {0}",year))("East")("North")(dataSet)
2019-03-19 23:10:11 - open System
2019-03-19 23:10:11 - open System.Linq
2019-03-19 23:10:11 - open HousePriceAnalysis
2019-03-19 23:10:11 - open Statistics
2019-03-19 23:10:11 - open DataSet
2019-03-19 23:10:11 - open PGraphs
2019-03-19 23:10:11 - #load "XPlot.Plotly.fsx"
2019-03-19 23:10:47 - //DISTRIBUTION
2019-03-19 23:10:47 - let year=2016
2019-03-19 23:10:47 - let dataSet = SomeTransactions(fun h -> h.Date.Year=year) |> Seq.map (fun (p,h) -> (p.Eastings, p.Northings, h.Price) )
2019-03-19 23:10:47 - PGraphs.HeatMap(String.Format("House Prices in the UK - {0}",year))("East")("North")(dataSet)
2019-03-19 23:11:20 - let HeatMapAnalysis(filter:HousePriceReader.HousePriceInfo -> bool)(mapBox:float) =
2019-03-19 23:11:20 -     let y = SomeTransactions(filter)
2019-03-19 23:11:20 -     let dataSet = y |> Seq.map (fun (p,h) -> (p.Eastings, p.Northings, h.Price) )
2019-03-19 23:11:20 -     printfn "Total distributions %A" (dataSet.Count())
2019-03-19 23:11:20 -     let quantileDataSet = dataSet |> CollateBy(fun (x,y,v) -> (Math.Round(x/mapBox,0)*mapBox,Math.Round(y/mapBox,0)*mapBox))(QuantileBy(fun (x,y,v) -> v)(2)(4))
2019-03-19 23:11:20 -     printfn "Geographic distributions %A" (quantileDataSet.Count())
2019-03-19 23:11:20 -     HeatMap("Median House Prices in the UK")("East")("North")(quantileDataSet.Select(fun((x,y),v)->(x,y,v)))
2019-03-19 23:11:22 - //HeatMapAnalysis(fun h -> h.Date.Year=2016 && h.TownCity.ToLower()="london")(500.0)
2019-03-19 23:11:22 - HeatMapAnalysis(fun h -> h.Date.Year=2016)(5000.0)
2019-03-19 23:11:29 - ////NATIONAL DISTRIBUTION OF MEDIAN HOUSE PRICES
2019-03-19 23:11:29 - Analyses.ShowHousePriceMap(1)(4)(5000.0)(fun h -> h.Date.Year=2016)
2019-03-19 23:14:02 - #load ".\DataAccess.fs"
2019-03-19 23:14:02 - #load ".\Statistics.fs"
2019-03-19 23:14:02 - #load ".\PGraphs.fs"
2019-03-19 23:14:02 - #load ".\Analyses.fs"
2019-03-19 23:14:03 - This expression was expected to have type
2019-03-19 23:14:03 -     'int'    
2019-03-19 23:14:03 - but here has type
2019-03-19 23:14:03 -     ''a * 'b'    
2019-03-19 23:14:03 - Type mismatch. Expecting a
2019-03-19 23:14:03 -     'seq<(int -> seq<float> -> float)> -> float []'    
2019-03-19 23:14:03 - but given a
2019-03-19 23:14:03 -     'seq<(int -> seq<float> -> float)> -> (int -> seq<float> -> float) []'    
2019-03-19 23:14:03 - The type 'float' does not match the type 'int -> seq<float> -> float'
2019-03-19 23:14:03 - This expression was expected to have type
2019-03-19 23:14:03 -     'int'    
2019-03-19 23:14:03 - but here has type
2019-03-19 23:14:03 -     ''a * 'b'    
2019-03-19 23:14:03 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-19 23:14:03 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-19 23:14:10 - #load ".\DataAccess.fs"
2019-03-19 23:14:10 - #load ".\Statistics.fs"
2019-03-19 23:14:10 - #load ".\PGraphs.fs"
2019-03-19 23:14:10 - #load ".\Analyses.fs"
2019-03-19 23:14:11 - This expression was expected to have type
2019-03-19 23:14:11 -     'int'    
2019-03-19 23:14:11 - but here has type
2019-03-19 23:14:11 -     ''a * 'b'    
2019-03-19 23:14:11 - Type mismatch. Expecting a
2019-03-19 23:14:11 -     'seq<(int -> seq<float> -> float)> -> float []'    
2019-03-19 23:14:11 - but given a
2019-03-19 23:14:11 -     'seq<(int -> seq<float> -> float)> -> (int -> seq<float> -> float) []'    
2019-03-19 23:14:11 - The type 'float' does not match the type 'int -> seq<float> -> float'
2019-03-19 23:14:11 - This expression was expected to have type
2019-03-19 23:14:11 -     'int'    
2019-03-19 23:14:11 - but here has type
2019-03-19 23:14:11 -     ''a * 'b'    
2019-03-19 23:14:11 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-19 23:14:11 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-19 23:15:26 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2019-03-19 23:15:26 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-03-19 23:15:26 - For help type #help;;
2019-03-19 23:15:26 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2019-03-19 23:15:26 -   seq []
2019-03-19 23:15:26 - --> Added 'D:\Applications\IfSharp.v3.0.0' to library include path
2019-03-19 23:15:26 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-03-19 23:15:26 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\NetMQ.dll' (file may be locked by F# Interactive process)
2019-03-19 23:15:26 - #load "Paket.fsx"
2019-03-19 23:15:26 - Paket.Package [
2019-03-19 23:15:26 -     "MathNet.Numerics"
2019-03-19 23:15:26 -     "MathNet.Numerics.FSharp"
2019-03-19 23:15:26 -     "XPlot.Plotly"
2019-03-19 23:15:26 -     ]
2019-03-19 23:15:26 - #load "Paket.Generated.Refs.fsx"
2019-03-19 23:15:41 - #load ".\DataAccess.fs"
2019-03-19 23:15:41 - #load ".\Statistics.fs"
2019-03-19 23:15:41 - #load ".\PGraphs.fs"
2019-03-19 23:15:41 - #load ".\Analyses.fs"
2019-03-19 23:15:48 - open System
2019-03-19 23:15:48 - open System.Linq
2019-03-19 23:15:48 - open HousePriceAnalysis
2019-03-19 23:15:48 - open Statistics
2019-03-19 23:15:48 - open DataSet
2019-03-19 23:15:48 - open PGraphs
2019-03-19 23:15:48 - #load "XPlot.Plotly.fsx"
2019-03-19 23:15:52 - //DISTRIBUTION
2019-03-19 23:15:52 - let year=2016
2019-03-19 23:15:52 - let dataSet = SomeTransactions(fun h -> h.Date.Year=year) |> Seq.map (fun (p,h) -> (p.Eastings, p.Northings, h.Price) )
2019-03-19 23:15:52 - PGraphs.HeatMap(String.Format("House Prices in the UK - {0}",year))("East")("North")(dataSet)
2019-03-19 23:16:10 - let HeatMapAnalysis(filter:HousePriceReader.HousePriceInfo -> bool)(mapBox:float) =
2019-03-19 23:16:10 -     let y = SomeTransactions(filter)
2019-03-19 23:16:10 -     let dataSet = y |> Seq.map (fun (p,h) -> (p.Eastings, p.Northings, h.Price) )
2019-03-19 23:16:10 -     printfn "Total distributions %A" (dataSet.Count())
2019-03-19 23:16:10 -     let quantileDataSet = dataSet |> CollateBy(fun (x,y,v) -> (Math.Round(x/mapBox,0)*mapBox,Math.Round(y/mapBox,0)*mapBox))(QuantileBy(fun (x,y,v) -> v)(2)(4))
2019-03-19 23:16:10 -     printfn "Geographic distributions %A" (quantileDataSet.Count())
2019-03-19 23:16:10 -     HeatMap("Median House Prices in the UK")("East")("North")(quantileDataSet.Select(fun((x,y),v)->(x,y,v)))
2019-03-19 23:16:16 - //HeatMapAnalysis(fun h -> h.Date.Year=2016 && h.TownCity.ToLower()="london")(500.0)
2019-03-19 23:16:16 - HeatMapAnalysis(fun h -> h.Date.Year=2016)(5000.0)
2019-03-19 23:16:22 - ////NATIONAL DISTRIBUTION OF MEDIAN HOUSE PRICES
2019-03-19 23:16:22 - Analyses.ShowHousePriceMap(1)(4)(5000.0)(fun h -> h.Date.Year=2016)
2019-03-19 23:16:26 - Analyses.ShowHousePriceMap(2)(4)(5000.0)(fun h -> h.Date.Year=2016)
2019-03-19 23:16:31 - Analyses.ShowHousePriceMap(3)(4)(5000.0)(fun h -> h.Date.Year=2016)
2019-03-19 23:16:35 - Analyses.ShowHousePriceMap(4)(4)(5000.0)(fun h -> h.Date.Year=2016)
2019-03-20 07:24:09 - # @hidden_cell
2019-03-20 07:24:09 - #load "Paket.fsx"
2019-03-20 07:24:09 - Paket.Package [
2019-03-20 07:24:09 -     "MathNet.Numerics"
2019-03-20 07:24:09 -     "MathNet.Numerics.FSharp"
2019-03-20 07:24:09 -     "XPlot.Plotly"
2019-03-20 07:24:09 -     ]
2019-03-20 07:24:09 - #load "Paket.Generated.Refs.fsx"
2019-03-20 07:24:09 - #load "XPlot.Plotly.fsx"
2019-03-20 07:24:10 - Unexpected infix operator in directive. Expected identifier or other token.
2019-03-20 07:24:10 - parse error
2019-03-20 07:24:15 - #load "Paket.fsx"
2019-03-20 07:24:15 - Paket.Package [
2019-03-20 07:24:15 -     "MathNet.Numerics"
2019-03-20 07:24:15 -     "MathNet.Numerics.FSharp"
2019-03-20 07:24:15 -     "XPlot.Plotly"
2019-03-20 07:24:15 -     ]
2019-03-20 07:24:15 - #load "Paket.Generated.Refs.fsx"
2019-03-20 07:24:15 - #load "XPlot.Plotly.fsx"
2019-03-20 07:27:17 - //DISTRIBUTION
2019-03-20 07:27:17 - let year=2016
2019-03-20 07:27:17 -  
2019-03-20 07:27:17 - SomeTransactions(fun h -> h.Date.Year=year) 
2019-03-20 07:27:17 -     |> Seq.map (fun (p,h) -> (p.Eastings, p.Northings, h.Price) )
2019-03-20 07:27:17 -     |> PGraphs.HeatMap(String.Format("House Prices in the UK - {0}",year))("East")("North")
2019-03-20 07:27:17 - //PGraphs.HeatMap(String.Format("House Prices in the UK - {0}",year))("East")("North")(dataSet)
2019-03-20 07:28:29 - Analyses.HeatMapAnalysis(fun h -> h.Date.Year=2016 && h.TownCity.ToLower()="london")(500.0)
2019-03-20 07:28:29 - The value, constructor, namespace or type 'HeatMapAnalysis' is not defined.
2019-03-20 07:28:59 - Analyses.HeatMapAnalysis(fun h -> h.Date.Year=2016)(5000.0)
2019-03-20 07:28:59 - The value, constructor, namespace or type 'HeatMapAnalysis' is not defined.
2019-03-20 07:29:07 - #load ".\DataAccess.fs"
2019-03-20 07:29:07 - #load ".\Statistics.fs"
2019-03-20 07:29:07 - #load ".\PGraphs.fs"
2019-03-20 07:29:07 - #load ".\Analyses.fs"
2019-03-20 07:29:08 - This expression was expected to have type
2019-03-20 07:29:08 -     'int'    
2019-03-20 07:29:08 - but here has type
2019-03-20 07:29:08 -     ''a * 'b'    
2019-03-20 07:29:08 - Type mismatch. Expecting a
2019-03-20 07:29:08 -     'seq<(int -> seq<float> -> float)> -> float []'    
2019-03-20 07:29:08 - but given a
2019-03-20 07:29:08 -     'seq<(int -> seq<float> -> float)> -> (int -> seq<float> -> float) []'    
2019-03-20 07:29:08 - The type 'float' does not match the type 'int -> seq<float> -> float'
2019-03-20 07:29:08 - This expression was expected to have type
2019-03-20 07:29:08 -     'int'    
2019-03-20 07:29:08 - but here has type
2019-03-20 07:29:08 -     ''a * 'b'    
2019-03-20 07:29:08 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-20 07:29:08 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-20 07:29:16 - #load ".\DataAccess.fs"
2019-03-20 07:29:16 - #load ".\Statistics.fs"
2019-03-20 07:29:16 - #load ".\PGraphs.fs"
2019-03-20 07:29:16 - #load ".\Analyses.fs"
2019-03-20 07:29:17 - This expression was expected to have type
2019-03-20 07:29:17 -     'int'    
2019-03-20 07:29:17 - but here has type
2019-03-20 07:29:17 -     ''a * 'b'    
2019-03-20 07:29:17 - Type mismatch. Expecting a
2019-03-20 07:29:17 -     'seq<(int -> seq<float> -> float)> -> float []'    
2019-03-20 07:29:17 - but given a
2019-03-20 07:29:17 -     'seq<(int -> seq<float> -> float)> -> (int -> seq<float> -> float) []'    
2019-03-20 07:29:17 - The type 'float' does not match the type 'int -> seq<float> -> float'
2019-03-20 07:29:17 - This expression was expected to have type
2019-03-20 07:29:17 -     'int'    
2019-03-20 07:29:17 - but here has type
2019-03-20 07:29:17 -     ''a * 'b'    
2019-03-20 07:29:17 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-20 07:29:17 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-20 07:29:25 - shutdown request
2019-03-20 07:29:35 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2019-03-20 07:29:35 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-03-20 07:29:35 - For help type #help;;
2019-03-20 07:29:35 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2019-03-20 07:29:35 -   seq []
2019-03-20 07:29:35 - --> Added 'D:\Applications\IfSharp.v3.0.0' to library include path
2019-03-20 07:29:35 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-03-20 07:29:35 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\NetMQ.dll' (file may be locked by F# Interactive process)
2019-03-20 07:29:37 - #load "Paket.fsx"
2019-03-20 07:29:37 - Paket.Package [
2019-03-20 07:29:37 -     "MathNet.Numerics"
2019-03-20 07:29:37 -     "MathNet.Numerics.FSharp"
2019-03-20 07:29:37 -     "XPlot.Plotly"
2019-03-20 07:29:37 -     ]
2019-03-20 07:29:37 - #load "Paket.Generated.Refs.fsx"
2019-03-20 07:29:37 - #load "XPlot.Plotly.fsx"
2019-03-20 07:29:54 - #load ".\DataAccess.fs"
2019-03-20 07:29:54 - #load ".\Statistics.fs"
2019-03-20 07:29:54 - #load ".\PGraphs.fs"
2019-03-20 07:29:54 - #load ".\Analyses.fs"
2019-03-20 07:29:56 - The field, constructor or member 'Count' is not defined.
2019-03-20 07:29:56 - The field, constructor or member 'Count' is not defined.
2019-03-20 07:29:56 - The field, constructor or member 'Select' is not defined.
2019-03-20 07:30:30 - #load ".\DataAccess.fs"
2019-03-20 07:30:30 - #load ".\Statistics.fs"
2019-03-20 07:30:30 - #load ".\PGraphs.fs"
2019-03-20 07:30:30 - #load ".\Analyses.fs"
2019-03-20 07:30:35 - open System
2019-03-20 07:30:35 - open HousePriceAnalysis
2019-03-20 07:30:35 - open Statistics
2019-03-20 07:30:35 - open DataSet
2019-03-20 07:30:35 - open PGraphs
2019-03-20 07:31:03 - //DISTRIBUTION
2019-03-20 07:31:03 - let year=2016
2019-03-20 07:31:03 -  
2019-03-20 07:31:03 - SomeTransactions(fun h -> h.Date.Year=year) 
2019-03-20 07:31:03 -     |> Seq.map (fun (p,h) -> (p.Eastings, p.Northings, h.Price) )
2019-03-20 07:31:03 -     |> PGraphs.HeatMap(String.Format("House Prices in the UK - {0}",year))("East")("North")
2019-03-20 07:31:03 -     
2019-03-20 07:31:24 - Analyses.HeatMapAnalysis(fun h -> h.Date.Year=2016)(5000.0)
2019-03-20 07:31:32 - Analyses.HeatMapAnalysis(fun h -> h.Date.Year=2016 && h.TownCity.ToLower()="london")(500.0)
2019-03-20 07:32:02 - Analyses.HeatMapAnalysis(fun h -> h.Date.Year=2016 && h.TownCity.ToLower()="manchester")(500.0)
2019-03-20 07:37:39 - #load ".\DataAccess.fs"
2019-03-20 07:37:39 - #load ".\Statistics.fs"
2019-03-20 07:37:39 - #load ".\PGraphs.fs"
2019-03-20 07:37:39 - #load ".\Analyses.fs"
2019-03-20 07:37:40 - This expression was expected to have type
2019-03-20 07:37:40 -     'int'    
2019-03-20 07:37:40 - but here has type
2019-03-20 07:37:40 -     ''a * 'b'    
2019-03-20 07:37:40 - Type mismatch. Expecting a
2019-03-20 07:37:40 -     'seq<(int -> seq<float> -> float)> -> float []'    
2019-03-20 07:37:40 - but given a
2019-03-20 07:37:40 -     'seq<(int -> seq<float> -> float)> -> (int -> seq<float> -> float) []'    
2019-03-20 07:37:40 - The type 'float' does not match the type 'int -> seq<float> -> float'
2019-03-20 07:37:40 - This expression was expected to have type
2019-03-20 07:37:40 -     'int'    
2019-03-20 07:37:40 - but here has type
2019-03-20 07:37:40 -     ''a * 'b'    
2019-03-20 07:37:40 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-20 07:37:40 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-20 07:38:10 - shutdown request
2019-03-20 07:38:17 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2019-03-20 07:38:17 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-03-20 07:38:17 - For help type #help;;
2019-03-20 07:38:17 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2019-03-20 07:38:17 -   seq []
2019-03-20 07:38:17 - --> Added 'D:\Applications\IfSharp.v3.0.0' to library include path
2019-03-20 07:38:17 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-03-20 07:38:17 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\NetMQ.dll' (file may be locked by F# Interactive process)
2019-03-20 07:38:17 - #load "Paket.fsx"
2019-03-20 07:38:17 - Paket.Package [
2019-03-20 07:38:17 -     "MathNet.Numerics"
2019-03-20 07:38:17 -     "MathNet.Numerics.FSharp"
2019-03-20 07:38:17 -     "XPlot.Plotly"
2019-03-20 07:38:17 -     ]
2019-03-20 07:38:17 - #load "Paket.Generated.Refs.fsx"
2019-03-20 07:38:17 - #load "XPlot.Plotly.fsx"
2019-03-20 07:38:28 - #load ".\DataAccess.fs"
2019-03-20 07:38:28 - #load ".\Statistics.fs"
2019-03-20 07:38:28 - #load ".\PGraphs.fs"
2019-03-20 07:38:28 - #load ".\Analyses.fs"
2019-03-20 07:38:30 - The value or constructor 'year' is not defined.
2019-03-20 07:39:17 - shutdown request
2019-03-20 07:39:28 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2019-03-20 07:39:28 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-03-20 07:39:28 - For help type #help;;
2019-03-20 07:39:28 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2019-03-20 07:39:28 -   seq []
2019-03-20 07:39:28 - --> Added 'D:\Applications\IfSharp.v3.0.0' to library include path
2019-03-20 07:39:28 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-03-20 07:39:28 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\NetMQ.dll' (file may be locked by F# Interactive process)
2019-03-20 07:39:28 - #load "Paket.fsx"
2019-03-20 07:39:28 - Paket.Package [
2019-03-20 07:39:28 -     "MathNet.Numerics"
2019-03-20 07:39:28 -     "MathNet.Numerics.FSharp"
2019-03-20 07:39:28 -     "XPlot.Plotly"
2019-03-20 07:39:28 -     ]
2019-03-20 07:39:28 - #load "Paket.Generated.Refs.fsx"
2019-03-20 07:39:28 - #load "XPlot.Plotly.fsx"
2019-03-20 07:39:28 - #load ".\DataAccess.fs"
2019-03-20 07:39:28 - #load ".\Statistics.fs"
2019-03-20 07:39:28 - #load ".\PGraphs.fs"
2019-03-20 07:39:28 - #load ".\Analyses.fs"
2019-03-20 07:39:37 - open System
2019-03-20 07:39:37 - open HousePriceAnalysis
2019-03-20 07:39:37 - open Statistics
2019-03-20 07:39:37 - open DataSet
2019-03-20 07:39:37 - open PGraphs
2019-03-20 07:39:41 - //DISTRIBUTION
2019-03-20 07:39:41 - Analyses.RawHousePriceMap(fun h -> h.Date.Year=2016)
2019-03-20 07:39:41 - //SomeTransactions(fun h -> h.Date.Year=year) 
2019-03-20 07:39:41 - //    |> Seq.map (fun (p,h) -> (p.Eastings, p.Northings, h.Price) )
2019-03-20 07:39:41 - //    |> PGraphs.HeatMap(String.Format("House Prices in the UK - {0}",year))("East")("North")
2019-03-20 07:39:41 -     
2019-03-20 07:41:16 - Analyses.RawHousePriceMap(fun h -> h.Date.Year=2016 && h.TownCity.ToLower()="london")
2019-03-20 07:42:19 - Analyses.RawHousePriceMap(fun h -> h.Date.Year=2016 && h.TownCity.ToLower()="manchester")
2019-03-20 11:33:03 - Analyses.RawHousePriceMap(fun h -> h.Date.Year=2016 && 
2019-03-20 11:33:03 -                                     (h.TownCity.ToLower()="london"
2019-03-20 11:33:03 -                                         || h.TownCity.ToLower()="manchester"
2019-03-20 11:33:03 -                                         || h.TownCity.ToLower()="birmingham")
2019-03-20 11:33:04 - Unmatched '('
2019-03-20 11:33:07 - Analyses.RawHousePriceMap(fun h -> h.Date.Year=2016 && 
2019-03-20 11:33:07 -                                     (h.TownCity.ToLower()="london"
2019-03-20 11:33:07 -                                         || h.TownCity.ToLower()="manchester"
2019-03-20 11:33:07 -                                         || h.TownCity.ToLower()="birmingham"))
2019-03-20 11:44:28 - let priceFilter =
2019-03-20 11:44:28 -     fun h -> h.Date.Year=2016 && 
2019-03-20 11:44:28 -                 (h.TownCity.ToLower()="london"
2019-03-20 11:44:28 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 11:44:28 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 11:44:28 - let cityValues = 
2019-03-20 11:44:28 -     SomeTransactions(priceFilter)
2019-03-20 11:44:28 -         |> Seq.map (fun (p,h) -> {City=h.TownCity.ToLower();Price=float h.Price})
2019-03-20 11:44:28 -         |> Seq.groupBy (fun v -> v.City)
2019-03-20 11:44:28 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun p -> p.Price) |> Statistics.Quantiles(4)))
2019-03-20 11:44:29 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-03-20 11:44:29 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-03-20 11:44:29 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-03-20 11:44:29 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-03-20 11:44:29 - The record label 'City' is not defined.
2019-03-20 11:44:29 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-03-20 11:44:29 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-03-20 11:58:53 - let priceFilter:HousePriceReader.HousePriceInfo -> bool =
2019-03-20 11:58:53 -     fun h -> h.Date.Year=2016 && 
2019-03-20 11:58:53 -                 (h.TownCity.ToLower()="london"
2019-03-20 11:58:53 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 11:58:53 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 11:58:53 - //type CityPrices
2019-03-20 11:58:53 - let cityValues = 
2019-03-20 11:58:53 -     SomeTransactions(priceFilter)
2019-03-20 11:58:53 -         //|> Seq.map (fun (p,h) -> { City=h.TownCity.ToLower(); Price=float h.Price})
2019-03-20 11:58:53 -         |> Seq.groupBy (fun (p,h) -> h.TownCity.ToLower())
2019-03-20 11:58:53 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Statistics.Quantiles(4)))
2019-03-20 11:58:53 - cityValues
2019-03-20 11:58:53 -     |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 11:58:53 -     |> XPlot.Plotly.Chart.Plot
2019-03-20 11:58:53 - The value or constructor 'Box' is not defined. Maybe you want one of the following:
2019-03-20 11:58:53 -    box
2019-03-20 11:58:53 -    unbox
2019-03-20 11:59:02 - let priceFilter:HousePriceReader.HousePriceInfo -> bool =
2019-03-20 11:59:02 -     fun h -> h.Date.Year=2016 && 
2019-03-20 11:59:02 -                 (h.TownCity.ToLower()="london"
2019-03-20 11:59:02 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 11:59:02 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 11:59:02 - //type CityPrices
2019-03-20 11:59:02 - let cityValues = 
2019-03-20 11:59:02 -     SomeTransactions(priceFilter)
2019-03-20 11:59:02 -         //|> Seq.map (fun (p,h) -> { City=h.TownCity.ToLower(); Price=float h.Price})
2019-03-20 11:59:02 -         |> Seq.groupBy (fun (p,h) -> h.TownCity.ToLower())
2019-03-20 11:59:02 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Statistics.Quantiles(4)))
2019-03-20 11:59:02 - cityValues
2019-03-20 11:59:02 -     |> Seq.map(fun (c,q) -> XPlot.Plotly.Box(y=q, name=c))
2019-03-20 11:59:02 -     |> XPlot.Plotly.Chart.Plot
2019-03-20 11:59:03 - The value, constructor, namespace or type 'Box' is not defined.
2019-03-20 11:59:11 - let priceFilter:HousePriceReader.HousePriceInfo -> bool =
2019-03-20 11:59:11 -     fun h -> h.Date.Year=2016 && 
2019-03-20 11:59:11 -                 (h.TownCity.ToLower()="london"
2019-03-20 11:59:11 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 11:59:11 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 11:59:11 - //type CityPrices
2019-03-20 11:59:11 - let cityValues = 
2019-03-20 11:59:11 -     SomeTransactions(priceFilter)
2019-03-20 11:59:11 -         //|> Seq.map (fun (p,h) -> { City=h.TownCity.ToLower(); Price=float h.Price})
2019-03-20 11:59:11 -         |> Seq.groupBy (fun (p,h) -> h.TownCity.ToLower())
2019-03-20 11:59:11 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Statistics.Quantiles(4)))
2019-03-20 11:59:11 - cityValues
2019-03-20 11:59:11 -     |> Seq.map(fun (c,q) -> XPlot.Box(y=q, name=c))
2019-03-20 11:59:11 -     |> XPlot.Plotly.Chart.Plot
2019-03-20 11:59:11 - The value, constructor, namespace or type 'Box' is not defined.
2019-03-20 12:04:03 - let priceFilter:HousePriceReader.HousePriceInfo -> bool =
2019-03-20 12:04:03 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:04:03 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:04:03 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:04:03 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 12:04:03 - //type CityPrices
2019-03-20 12:04:03 - let cityValues = 
2019-03-20 12:04:03 -     SomeTransactions(priceFilter)
2019-03-20 12:04:03 -         //|> Seq.map (fun (p,h) -> { City=h.TownCity.ToLower(); Price=float h.Price})
2019-03-20 12:04:03 -         |> Seq.groupBy (fun (p,h) -> h.TownCity.ToLower())
2019-03-20 12:04:03 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Statistics.Quantiles(4)))
2019-03-20 12:04:03 - cityValues
2019-03-20 12:04:03 -     |> Seq.map(fun (c,q) -> Fsharp.Box(y=q, name=c))
2019-03-20 12:04:03 -     |> XPlot.Plotly.Chart.Plot
2019-03-20 12:04:03 - The value, namespace, type or module 'Fsharp' is not defined. Maybe you want one of the following:
2019-03-20 12:04:03 -    FSharp
2019-03-20 12:04:03 -    IfSharp
2019-03-20 12:04:03 -    FSharpFunc
2019-03-20 12:04:03 -    FSharpTypeFunc
2019-03-20 12:04:09 - let priceFilter:HousePriceReader.HousePriceInfo -> bool =
2019-03-20 12:04:09 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:04:09 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:04:09 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:04:09 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 12:04:09 - //type CityPrices
2019-03-20 12:04:09 - let cityValues = 
2019-03-20 12:04:09 -     SomeTransactions(priceFilter)
2019-03-20 12:04:09 -         //|> Seq.map (fun (p,h) -> { City=h.TownCity.ToLower(); Price=float h.Price})
2019-03-20 12:04:09 -         |> Seq.groupBy (fun (p,h) -> h.TownCity.ToLower())
2019-03-20 12:04:09 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Statistics.Quantiles(4)))
2019-03-20 12:04:09 - cityValues
2019-03-20 12:04:09 -     |> Seq.map(fun (c,q) -> FSharp.Box(y=q, name=c))
2019-03-20 12:04:09 -     |> XPlot.Plotly.Chart.Plot
2019-03-20 12:04:09 - The value, constructor, namespace or type 'Box' is not defined.
2019-03-20 12:06:43 - let priceFilter:HousePriceReader.HousePriceInfo -> bool =
2019-03-20 12:06:43 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:06:43 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:06:43 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:06:43 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 12:06:43 - //type CityPrices
2019-03-20 12:06:43 - let cityValues = 
2019-03-20 12:06:43 -     SomeTransactions(priceFilter)
2019-03-20 12:06:43 -         //|> Seq.map (fun (p,h) -> { City=h.TownCity.ToLower(); Price=float h.Price})
2019-03-20 12:06:43 -         |> Seq.groupBy (fun (p,h) -> h.TownCity.ToLower())
2019-03-20 12:06:43 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Statistics.Quantiles(4)))
2019-03-20 12:06:43 - open XPlot.Plotly
2019-03-20 12:06:43 - cityValues
2019-03-20 12:06:43 -     |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:06:43 -     |> Chart.Plot
2019-03-20 12:11:40 - open HousePriceReader
2019-03-20 12:11:40 - open Statistics
2019-03-20 12:11:40 - open XPlot.Plotly
2019-03-20 12:11:40 - let priceFilter:HousePriceInfo -> bool =
2019-03-20 12:11:40 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:11:40 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:11:40 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:11:40 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 12:11:40 -                     
2019-03-20 12:11:40 - let boxGrouper:HousePriceInfo -> string =
2019-03-20 12:11:40 -     fun h -> h.TownCity.ToLower()
2019-03-20 12:11:40 - let ntiles:int=4
2019-03-20 12:11:40 - //type CityPrices
2019-03-20 12:11:40 - let cityValues = 
2019-03-20 12:11:40 -     SomeTransactions(priceFilter)
2019-03-20 12:11:40 -         |> Seq.groupBy (fun (p,h) -> boxGrouper)
2019-03-20 12:11:40 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Quantiles(ntiles)))
2019-03-20 12:11:40 -         |> Seq.sortBy (fun (c,q) -> q[ntiles/2])
2019-03-20 12:11:40 - cityValues
2019-03-20 12:11:40 -     |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:11:40 -     |> Chart.Plot
2019-03-20 12:11:40 - The type '(HousePriceInfo -> string)' does not support the 'equality' constraint because it is a function type
2019-03-20 12:11:40 - This value is not a function and cannot be applied. Did you intend to access the indexer via q.[index] instead?
2019-03-20 12:11:40 - This expression was expected to have type
2019-03-20 12:11:40 -     'string'    
2019-03-20 12:11:40 - but here has type
2019-03-20 12:11:40 -     'HousePriceInfo -> string'    
2019-03-20 12:11:56 - open HousePriceReader
2019-03-20 12:11:56 - open Statistics
2019-03-20 12:11:56 - open XPlot.Plotly
2019-03-20 12:11:56 - let priceFilter:HousePriceInfo -> bool =
2019-03-20 12:11:56 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:11:56 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:11:56 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:11:56 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 12:11:56 -                     
2019-03-20 12:11:56 - let boxGrouper:HousePriceInfo -> string =
2019-03-20 12:11:56 -     fun h -> h.TownCity.ToLower()
2019-03-20 12:11:56 - let ntiles:int=4
2019-03-20 12:11:56 - //type CityPrices
2019-03-20 12:11:56 - let cityValues = 
2019-03-20 12:11:56 -     SomeTransactions(priceFilter)
2019-03-20 12:11:56 -         |> Seq.groupBy (fun (p,h) -> boxGrouper)
2019-03-20 12:11:56 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Quantiles(ntiles)))
2019-03-20 12:11:56 -         |> Seq.sortBy (fun (c,q) -> q.[ntiles/2])
2019-03-20 12:11:56 - cityValues
2019-03-20 12:11:56 -     |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:11:56 -     |> Chart.Plot
2019-03-20 12:11:56 - The type '(HousePriceInfo -> string)' does not support the 'equality' constraint because it is a function type
2019-03-20 12:11:56 - This expression was expected to have type
2019-03-20 12:11:56 -     'string'    
2019-03-20 12:11:56 - but here has type
2019-03-20 12:11:56 -     'HousePriceInfo -> string'    
2019-03-20 12:12:27 - open HousePriceReader
2019-03-20 12:12:27 - open Statistics
2019-03-20 12:12:27 - open XPlot.Plotly
2019-03-20 12:12:27 - let priceFilter:HousePriceInfo -> bool =
2019-03-20 12:12:27 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:12:27 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:12:27 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:12:27 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 12:12:27 -                     
2019-03-20 12:12:27 - let boxGrouper:HousePriceInfo -> string =
2019-03-20 12:12:27 -     fun h -> h.TownCity.ToLower()
2019-03-20 12:12:27 - let ntiles:int=4
2019-03-20 12:12:27 - //type CityPrices
2019-03-20 12:12:27 - let cityValues = 
2019-03-20 12:12:27 -     SomeTransactions(priceFilter)
2019-03-20 12:12:27 -         |> Seq.groupBy (fun (p,h) -> boxGrouper(h))
2019-03-20 12:12:27 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Quantiles(ntiles)))
2019-03-20 12:12:27 -         |> Seq.sortBy (fun (c,q) -> q.[ntiles/2])
2019-03-20 12:12:27 - cityValues
2019-03-20 12:12:27 -     |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:12:27 -     |> Chart.Plot
2019-03-20 12:15:18 - open HousePriceReader
2019-03-20 12:15:18 - open Statistics
2019-03-20 12:15:18 - open XPlot.Plotly
2019-03-20 12:15:18 - let priceFilter:HousePriceInfo -> bool =
2019-03-20 12:15:18 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:15:18 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:15:18 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:15:18 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 12:15:18 -                     
2019-03-20 12:15:18 - let boxGrouper:HousePriceInfo -> string =
2019-03-20 12:15:18 -     fun h -> h.TownCity.ToLower()
2019-03-20 12:15:18 - let ntiles:int=5
2019-03-20 12:15:18 - //type CityPrices
2019-03-20 12:15:18 - let cityValues = 
2019-03-20 12:15:18 -     SomeTransactions(priceFilter)
2019-03-20 12:15:18 -         |> Seq.groupBy (fun (p,h) -> boxGrouper(h))
2019-03-20 12:15:18 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Quantiles(ntiles)))
2019-03-20 12:15:18 -         |> Seq.sortBy (fun (c,q) -> q.[ntiles/2])
2019-03-20 12:15:18 - cityValues
2019-03-20 12:15:18 -     |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:15:18 -     |> Chart.Plot
2019-03-20 12:15:29 - open HousePriceReader
2019-03-20 12:15:29 - open Statistics
2019-03-20 12:15:29 - open XPlot.Plotly
2019-03-20 12:15:29 - let priceFilter:HousePriceInfo -> bool =
2019-03-20 12:15:29 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:15:29 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:15:29 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:15:29 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 12:15:29 -                     
2019-03-20 12:15:29 - let boxGrouper:HousePriceInfo -> string =
2019-03-20 12:15:29 -     fun h -> h.TownCity.ToLower()
2019-03-20 12:15:29 - let ntiles:int=5
2019-03-20 12:15:29 - //type CityPrices
2019-03-20 12:15:29 - let cityValues = 
2019-03-20 12:15:29 -     SomeTransactions(priceFilter)
2019-03-20 12:15:29 -         |> Seq.groupBy (fun (p,h) -> boxGrouper(h))
2019-03-20 12:15:29 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Quantiles(ntiles)))
2019-03-20 12:15:29 -         |> Seq.sortByDescending (fun (c,q) -> q.[ntiles/2])
2019-03-20 12:15:29 - cityValues
2019-03-20 12:15:29 -     |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:15:29 -     |> Chart.Plot
2019-03-20 12:17:08 - open HousePriceReader
2019-03-20 12:17:08 - open Statistics
2019-03-20 12:17:08 - open XPlot.Plotly
2019-03-20 12:17:08 - let priceFilter:HousePriceInfo -> bool =
2019-03-20 12:17:08 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:17:08 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:17:08 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:17:08 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 12:17:08 -                     
2019-03-20 12:17:08 - let boxGrouper:HousePriceInfo -> string =
2019-03-20 12:17:08 -     fun h -> h.TownCity.ToLower()
2019-03-20 12:17:08 - let ntiles:int=5
2019-03-20 12:17:08 - //type CityPrices
2019-03-20 12:17:08 - let cityValues = 
2019-03-20 12:17:08 -     SomeTransactions(priceFilter)
2019-03-20 12:17:08 -         |> Seq.groupBy (fun (p,h) -> boxGrouper(h))
2019-03-20 12:17:08 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Quantiles(4)))
2019-03-20 12:17:08 -         |> Seq.sortByDescending (fun (c,q) -> q.[ntiles/2])
2019-03-20 12:17:08 - cityValues
2019-03-20 12:17:08 - cityValues
2019-03-20 12:17:08 -     |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:17:08 -     |> Chart.Plot
2019-03-20 12:17:19 - open HousePriceReader
2019-03-20 12:17:19 - open Statistics
2019-03-20 12:17:19 - open XPlot.Plotly
2019-03-20 12:17:19 - let priceFilter:HousePriceInfo -> bool =
2019-03-20 12:17:19 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:17:19 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:17:19 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:17:19 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 12:17:19 -                     
2019-03-20 12:17:19 - let boxGrouper:HousePriceInfo -> string =
2019-03-20 12:17:19 -     fun h -> h.TownCity.ToLower()
2019-03-20 12:17:19 - let ntiles:int=5
2019-03-20 12:17:19 - //type CityPrices
2019-03-20 12:17:19 - let cityValues = 
2019-03-20 12:17:19 -     SomeTransactions(priceFilter)
2019-03-20 12:17:19 -         |> Seq.groupBy (fun (p,h) -> boxGrouper(h))
2019-03-20 12:17:19 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Quantiles(4)))
2019-03-20 12:17:19 -         |> Seq.sortByDescending (fun (c,q) -> q.[ntiles/2])
2019-03-20 12:17:19 - cityValues
2019-03-20 12:17:19 -     |> Util.table
2019-03-20 12:17:19 - cityValues
2019-03-20 12:17:19 -     |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:17:19 -     |> Chart.Plot
2019-03-20 12:17:19 - The field, constructor or member 'table' is not defined. Maybe you want one of the following:
2019-03-20 12:17:19 -    Table
2019-03-20 12:17:23 - open HousePriceReader
2019-03-20 12:17:23 - open Statistics
2019-03-20 12:17:23 - open XPlot.Plotly
2019-03-20 12:17:23 - let priceFilter:HousePriceInfo -> bool =
2019-03-20 12:17:23 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:17:23 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:17:23 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:17:23 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 12:17:23 -                     
2019-03-20 12:17:23 - let boxGrouper:HousePriceInfo -> string =
2019-03-20 12:17:23 -     fun h -> h.TownCity.ToLower()
2019-03-20 12:17:23 - let ntiles:int=5
2019-03-20 12:17:23 - //type CityPrices
2019-03-20 12:17:23 - let cityValues = 
2019-03-20 12:17:23 -     SomeTransactions(priceFilter)
2019-03-20 12:17:23 -         |> Seq.groupBy (fun (p,h) -> boxGrouper(h))
2019-03-20 12:17:23 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Quantiles(4)))
2019-03-20 12:17:23 -         |> Seq.sortByDescending (fun (c,q) -> q.[ntiles/2])
2019-03-20 12:17:23 - cityValues
2019-03-20 12:17:23 -     |> Util.Table
2019-03-20 12:17:23 - cityValues
2019-03-20 12:17:23 -     |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:17:23 -     |> Chart.Plot
2019-03-20 12:17:32 - open HousePriceReader
2019-03-20 12:17:32 - open Statistics
2019-03-20 12:17:32 - open XPlot.Plotly
2019-03-20 12:17:32 - let priceFilter:HousePriceInfo -> bool =
2019-03-20 12:17:32 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:17:32 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:17:32 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:17:32 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 12:17:32 -                     
2019-03-20 12:17:32 - let boxGrouper:HousePriceInfo -> string =
2019-03-20 12:17:32 -     fun h -> h.TownCity.ToLower()
2019-03-20 12:17:32 - let ntiles:int=5
2019-03-20 12:17:32 - //type CityPrices
2019-03-20 12:17:32 - let cityValues = 
2019-03-20 12:17:32 -     SomeTransactions(priceFilter)
2019-03-20 12:17:32 -         |> Seq.groupBy (fun (p,h) -> boxGrouper(h))
2019-03-20 12:17:32 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Quantiles(4)))
2019-03-20 12:17:32 -         |> Seq.sortByDescending (fun (c,q) -> q.[ntiles/2])
2019-03-20 12:17:32 - cityValues
2019-03-20 12:17:32 -     |> Util.Table
2019-03-20 12:17:32 - //cityValues
2019-03-20 12:17:32 -  //   |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:17:32 -   //  |> Chart.Plot
2019-03-20 12:18:14 - open HousePriceReader
2019-03-20 12:18:14 - open Statistics
2019-03-20 12:18:14 - open XPlot.Plotly
2019-03-20 12:18:14 - let priceFilter:HousePriceInfo -> bool =
2019-03-20 12:18:14 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:18:14 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:18:14 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:18:14 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 12:18:14 -                     
2019-03-20 12:18:14 - let boxGrouper:HousePriceInfo -> string =
2019-03-20 12:18:14 -     fun h -> h.TownCity.ToLower()
2019-03-20 12:18:14 - let ntiles:int=5
2019-03-20 12:18:14 - //type CityPrices
2019-03-20 12:18:14 - let cityValues = 
2019-03-20 12:18:14 -     SomeTransactions(priceFilter)
2019-03-20 12:18:14 -         |> Seq.groupBy (fun (p,h) -> boxGrouper(h))
2019-03-20 12:18:14 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Quantiles(4)))
2019-03-20 12:18:14 -         |> Seq.sortByDescending (fun (c,q) -> q.[ntiles/2])
2019-03-20 12:18:14 - cityValues
2019-03-20 12:18:14 -     |> Seq.map(fun (c,q) -> [c,q.[1],q.[2],q.[3]])
2019-03-20 12:18:14 -     |> Util.Table
2019-03-20 12:18:14 - //cityValues
2019-03-20 12:18:14 -  //   |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:18:14 -   //  |> Chart.Plot
2019-03-20 12:18:15 - Expression evaluation failed: Parameter count mismatch.
2019-03-20 12:18:15 - TargetParameterCountExceptionParameter count mismatch.
2019-03-20 12:18:15 -    at System.Reflection.RuntimeMethodInfo.InvokeArgumentsCheck(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
2019-03-20 12:18:15 -    at System.Reflection.RuntimeMethodInfo.Invoke(Object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)
2019-03-20 12:18:15 -    at System.Reflection.RuntimePropertyInfo.GetValue(Object obj, Object[] index)
2019-03-20 12:18:15 -    at <StartupCode$IfSharp-Kernel>.$Util.Row@81-1.Invoke(PropertyInfo p) in E:\dev\IfSharp\src\IfSharp.Kernel\Util.fs:line 81
2019-03-20 12:18:15 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& curr)
2019-03-20 12:18:15 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2019-03-20 12:18:15 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& curr)
2019-03-20 12:18:15 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2019-03-20 12:18:15 -    at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)
2019-03-20 12:18:15 -    at Microsoft.FSharp.Collections.SeqModule.ToArray[T](IEnumerable`1 source)
2019-03-20 12:18:15 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& curr)
2019-03-20 12:18:15 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2019-03-20 12:18:15 -    at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)
2019-03-20 12:18:15 -    at Microsoft.FSharp.Collections.SeqModule.ToArray[T](IEnumerable`1 source)
2019-03-20 12:18:15 -    at IfSharp.Kernel.Util.Table[A](IEnumerable`1 items, FSharpOption`1 propertyNames) in E:\dev\IfSharp\src\IfSharp.Kernel\Util.fs:line 98
2019-03-20 12:18:15 -    at <StartupCode$FSI_0046>.$FSI_0046.main@() in C:\Users\David\Documents\GitHub\millerdw.github.io\_notebooks\IllustratingThePoint_3\input.fsx:line 19
2019-03-20 12:18:22 - open HousePriceReader
2019-03-20 12:18:22 - open Statistics
2019-03-20 12:18:22 - open XPlot.Plotly
2019-03-20 12:18:22 - let priceFilter:HousePriceInfo -> bool =
2019-03-20 12:18:22 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:18:22 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:18:22 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:18:22 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 12:18:22 -                     
2019-03-20 12:18:22 - let boxGrouper:HousePriceInfo -> string =
2019-03-20 12:18:22 -     fun h -> h.TownCity.ToLower()
2019-03-20 12:18:22 - let ntiles:int=5
2019-03-20 12:18:22 - //type CityPrices
2019-03-20 12:18:22 - let cityValues = 
2019-03-20 12:18:22 -     SomeTransactions(priceFilter)
2019-03-20 12:18:22 -         |> Seq.groupBy (fun (p,h) -> boxGrouper(h))
2019-03-20 12:18:22 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Quantiles(4)))
2019-03-20 12:18:22 -         |> Seq.sortByDescending (fun (c,q) -> q.[ntiles/2])
2019-03-20 12:18:22 - cityValues
2019-03-20 12:18:22 -     |> Seq.map(fun (c,q) -> {c,q.[1],q.[2],q.[3]})
2019-03-20 12:18:22 -     |> Util.Table
2019-03-20 12:18:22 - //cityValues
2019-03-20 12:18:22 -  //   |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:18:22 -   //  |> Chart.Plot
2019-03-20 12:18:22 - Invalid object, sequence or record expression
2019-03-20 12:18:22 - Invalid record, sequence or computation expression. Sequence expressions should be of the form 'seq { ... }'
2019-03-20 12:18:29 - open HousePriceReader
2019-03-20 12:18:29 - open Statistics
2019-03-20 12:18:29 - open XPlot.Plotly
2019-03-20 12:18:29 - let priceFilter:HousePriceInfo -> bool =
2019-03-20 12:18:29 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:18:29 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:18:29 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:18:29 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 12:18:29 -                     
2019-03-20 12:18:29 - let boxGrouper:HousePriceInfo -> string =
2019-03-20 12:18:29 -     fun h -> h.TownCity.ToLower()
2019-03-20 12:18:29 - let ntiles:int=5
2019-03-20 12:18:29 - //type CityPrices
2019-03-20 12:18:29 - let cityValues = 
2019-03-20 12:18:29 -     SomeTransactions(priceFilter)
2019-03-20 12:18:29 -         |> Seq.groupBy (fun (p,h) -> boxGrouper(h))
2019-03-20 12:18:29 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Quantiles(4)))
2019-03-20 12:18:29 -         |> Seq.sortByDescending (fun (c,q) -> q.[ntiles/2])
2019-03-20 12:18:29 - cityValues
2019-03-20 12:18:29 -     |> Seq.map(fun (c,q) -> seq{c,q.[1],q.[2],q.[3]})
2019-03-20 12:18:29 -     |> Util.Table
2019-03-20 12:18:29 - //cityValues
2019-03-20 12:18:29 -  //   |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:18:29 -   //  |> Chart.Plot
2019-03-20 12:18:30 - Invalid object, sequence or record expression
2019-03-20 12:18:30 - The result of this expression has type 'string * float * float * float' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.
2019-03-20 12:19:40 - open HousePriceReader
2019-03-20 12:19:40 - open Statistics
2019-03-20 12:19:40 - open XPlot.Plotly
2019-03-20 12:19:40 - let priceFilter:HousePriceInfo -> bool =
2019-03-20 12:19:40 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:19:40 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:19:40 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:19:40 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 12:19:40 -                     
2019-03-20 12:19:40 - let boxGrouper:HousePriceInfo -> string =
2019-03-20 12:19:40 -     fun h -> h.TownCity.ToLower()
2019-03-20 12:19:40 - let ntiles:int=5
2019-03-20 12:19:40 - //type CityPrices
2019-03-20 12:19:40 - let cityValues = 
2019-03-20 12:19:40 -     SomeTransactions(priceFilter)
2019-03-20 12:19:40 -         |> Seq.groupBy (fun (p,h) -> boxGrouper(h))
2019-03-20 12:19:40 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Quantiles(4)))
2019-03-20 12:19:40 -         |> Seq.sortByDescending (fun (c,q) -> q.[ntiles/2])
2019-03-20 12:19:40 - type cityQTable = {City:string;q1:float;q2:float;q3:float}
2019-03-20 12:19:40 - cityValues
2019-03-20 12:19:40 -     |> Seq.map(fun (c,q) -> {City=c,q1=q.[1],q2=q.[2],q3=q.[3]})
2019-03-20 12:19:40 -     |> Util.Table
2019-03-20 12:19:40 - //cityValues
2019-03-20 12:19:40 -  //   |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:19:40 -   //  |> Chart.Plot
2019-03-20 12:19:40 - This expression was expected to have type
2019-03-20 12:19:40 -     'string'    
2019-03-20 12:19:40 - but here has type
2019-03-20 12:19:40 -     ''a * 'b * 'c * 'd'    
2019-03-20 12:19:40 - A ';' is used to separate field values in records. Consider replacing ',' with ';'.
2019-03-20 12:19:40 - No assignment given for field 'q1' of type 'FSI_0049.cityQTable'
2019-03-20 12:19:53 - open HousePriceReader
2019-03-20 12:19:53 - open Statistics
2019-03-20 12:19:53 - open XPlot.Plotly
2019-03-20 12:19:53 - let priceFilter:HousePriceInfo -> bool =
2019-03-20 12:19:53 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:19:53 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:19:53 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:19:53 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 12:19:53 -                     
2019-03-20 12:19:53 - let boxGrouper:HousePriceInfo -> string =
2019-03-20 12:19:53 -     fun h -> h.TownCity.ToLower()
2019-03-20 12:19:53 - let ntiles:int=5
2019-03-20 12:19:53 - //type CityPrices
2019-03-20 12:19:53 - let cityValues = 
2019-03-20 12:19:53 -     SomeTransactions(priceFilter)
2019-03-20 12:19:53 -         |> Seq.groupBy (fun (p,h) -> boxGrouper(h))
2019-03-20 12:19:53 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Quantiles(4)))
2019-03-20 12:19:53 -         |> Seq.sortByDescending (fun (c,q) -> q.[ntiles/2])
2019-03-20 12:19:53 - type cityQTable = {City:string;q1:float;q2:float;q3:float}
2019-03-20 12:19:53 - cityValues
2019-03-20 12:19:53 -     |> Seq.map(fun (c,q) -> {City=c;q1=q.[1];q2=q.[2];q3=q.[3]})
2019-03-20 12:19:53 -     |> Util.Table
2019-03-20 12:19:53 - //cityValues
2019-03-20 12:19:53 -  //   |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:19:53 -   //  |> Chart.Plot
2019-03-20 12:20:13 - open HousePriceReader
2019-03-20 12:20:13 - open Statistics
2019-03-20 12:20:13 - open XPlot.Plotly
2019-03-20 12:20:13 - let priceFilter:HousePriceInfo -> bool =
2019-03-20 12:20:13 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:20:13 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:20:13 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:20:13 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 12:20:13 -                     
2019-03-20 12:20:13 - let boxGrouper:HousePriceInfo -> string =
2019-03-20 12:20:13 -     fun h -> h.TownCity.ToLower()
2019-03-20 12:20:13 - let ntiles:int=5
2019-03-20 12:20:13 - //type CityPrices
2019-03-20 12:20:13 - let cityValues = 
2019-03-20 12:20:13 -     SomeTransactions(priceFilter)
2019-03-20 12:20:13 -         |> Seq.groupBy (fun (p,h) -> boxGrouper(h))
2019-03-20 12:20:13 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Quantiles(4)))
2019-03-20 12:20:13 -         |> Seq.sortByDescending (fun (c,q) -> q.[ntiles/2])
2019-03-20 12:20:13 - type cityQTable = {City:string;q0:float;q1:float;q2:float;q3:float}
2019-03-20 12:20:13 - cityValues
2019-03-20 12:20:13 -     |> Seq.map(fun (c,q) -> {City=c;q0=q.[0];q1=q.[1];q2=q.[2];q3=q.[3]})
2019-03-20 12:20:13 -     |> Util.Table
2019-03-20 12:20:13 - //cityValues
2019-03-20 12:20:13 -  //   |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:20:13 -   //  |> Chart.Plot
2019-03-20 12:20:47 - open HousePriceReader
2019-03-20 12:20:47 - open Statistics
2019-03-20 12:20:47 - open XPlot.Plotly
2019-03-20 12:20:47 - let priceFilter:HousePriceInfo -> bool =
2019-03-20 12:20:47 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:20:47 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:20:47 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:20:47 -                     || h.TownCity.ToLower()="birmingham")
2019-03-20 12:20:47 -                     
2019-03-20 12:20:47 - let boxGrouper:HousePriceInfo -> string =
2019-03-20 12:20:47 -     fun h -> h.TownCity.ToLower()
2019-03-20 12:20:47 - let ntiles:int=5
2019-03-20 12:20:47 - //type CityPrices
2019-03-20 12:20:47 - let cityValues = 
2019-03-20 12:20:47 -     SomeTransactions(priceFilter)
2019-03-20 12:20:47 -         |> Seq.groupBy (fun (p,h) -> boxGrouper(h))
2019-03-20 12:20:47 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Quantiles(4)))
2019-03-20 12:20:47 -         |> Seq.sortByDescending (fun (c,q) -> q.[ntiles/2])
2019-03-20 12:20:47 - type cityQTable = {City:string;q0:float;q1:float;q2:float;q3:float;q4:float}
2019-03-20 12:20:47 - cityValues
2019-03-20 12:20:47 -     |> Seq.map(fun (c,q) -> {City=c;q0=q.[0];q1=q.[1];q2=q.[2];q3=q.[3];q4=q.[4]})
2019-03-20 12:20:47 -     |> Util.Table
2019-03-20 12:20:47 - //cityValues
2019-03-20 12:20:47 -  //   |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:20:47 -   //  |> Chart.Plot
2019-03-20 12:21:51 - open HousePriceReader
2019-03-20 12:21:51 - open Statistics
2019-03-20 12:21:51 - open XPlot.Plotly
2019-03-20 12:21:51 - let priceFilter:HousePriceInfo -> bool =
2019-03-20 12:21:51 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:21:51 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:21:51 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:21:51 -                     || h.TownCity.ToLower()="birmingham"
2019-03-20 12:21:51 -                     || h.TownCity.ToLower()="oxford"
2019-03-20 12:21:51 -                     || h.TownCity.ToLower()="cambridge")
2019-03-20 12:21:51 -                     
2019-03-20 12:21:51 - let boxGrouper:HousePriceInfo -> string =
2019-03-20 12:21:51 -     fun h -> h.TownCity.ToLower()
2019-03-20 12:21:51 - let ntiles:int=5
2019-03-20 12:21:51 - //type CityPrices
2019-03-20 12:21:51 - let cityValues = 
2019-03-20 12:21:51 -     SomeTransactions(priceFilter)
2019-03-20 12:21:51 -         |> Seq.groupBy (fun (p,h) -> boxGrouper(h))
2019-03-20 12:21:51 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Quantiles(4)))
2019-03-20 12:21:51 -         |> Seq.sortByDescending (fun (c,q) -> q.[ntiles/2])
2019-03-20 12:21:51 - type cityQTable = {City:string;q0:float;q1:float;q2:float;q3:float;q4:float}
2019-03-20 12:21:51 - cityValues
2019-03-20 12:21:51 -     |> Seq.map(fun (c,q) -> {City=c;q0=q.[0];q1=q.[1];q2=q.[2];q3=q.[3];q4=q.[4]})
2019-03-20 12:21:51 -     |> Util.Table
2019-03-20 12:21:51 - //cityValues
2019-03-20 12:21:51 -  //   |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:21:51 -   //  |> Chart.Plot
2019-03-20 12:22:15 - open HousePriceReader
2019-03-20 12:22:15 - open Statistics
2019-03-20 12:22:15 - open XPlot.Plotly
2019-03-20 12:22:15 - let priceFilter:HousePriceInfo -> bool =
2019-03-20 12:22:15 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:22:15 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:22:15 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:22:15 -                     || h.TownCity.ToLower()="birmingham"
2019-03-20 12:22:15 -                     || h.TownCity.ToLower()="oxford"
2019-03-20 12:22:15 -                     || h.TownCity.ToLower()="cambridge")
2019-03-20 12:22:15 -                     
2019-03-20 12:22:15 - let boxGrouper:HousePriceInfo -> string =
2019-03-20 12:22:15 -     fun h -> h.TownCity.ToLower()
2019-03-20 12:22:15 - let ntiles:int=5
2019-03-20 12:22:15 - //type CityPrices
2019-03-20 12:22:15 - let cityValues = 
2019-03-20 12:22:15 -     SomeTransactions(priceFilter)
2019-03-20 12:22:15 -         |> Seq.groupBy (fun (p,h) -> boxGrouper(h))
2019-03-20 12:22:15 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Quantiles(4)))
2019-03-20 12:22:15 -         |> Seq.sortByDescending (fun (c,q) -> q.[ntiles/2])
2019-03-20 12:22:15 - type cityQTable = {City:string;q0:float;q1:float;q2:float;q3:float;q4:float;q5:float}
2019-03-20 12:22:15 - cityValues
2019-03-20 12:22:15 -     |> Seq.map(fun (c,q) -> {City=c;q0=q.[0];q1=q.[1];q2=q.[2];q3=q.[3];q4=q.[4];q5=q.[5]})
2019-03-20 12:22:15 -     |> Util.Table
2019-03-20 12:22:15 - //cityValues
2019-03-20 12:22:15 -  //   |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:22:15 -   //  |> Chart.Plot
2019-03-20 12:22:16 - Expression evaluation failed: Index was outside the bounds of the array.
2019-03-20 12:22:16 - IndexOutOfRangeExceptionIndex was outside the bounds of the array.
2019-03-20 12:22:16 -    at FSI_0058.it@29-15.Invoke(Tuple`2 tupledArg) in C:\Users\David\Documents\GitHub\millerdw.github.io\_notebooks\IllustratingThePoint_3\input.fsx:line 0
2019-03-20 12:22:16 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& curr)
2019-03-20 12:22:16 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2019-03-20 12:22:16 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& curr)
2019-03-20 12:22:16 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2019-03-20 12:22:16 -    at System.Collections.Generic.List`1..ctor(IEnumerable`1 collection)
2019-03-20 12:22:16 -    at Microsoft.FSharp.Collections.SeqModule.ToArray[T](IEnumerable`1 source)
2019-03-20 12:22:16 -    at IfSharp.Kernel.Util.Table[A](IEnumerable`1 items, FSharpOption`1 propertyNames) in E:\dev\IfSharp\src\IfSharp.Kernel\Util.fs:line 98
2019-03-20 12:22:16 -    at <StartupCode$FSI_0058>.$FSI_0058.main@() in C:\Users\David\Documents\GitHub\millerdw.github.io\_notebooks\IllustratingThePoint_3\input.fsx:line 21
2019-03-20 12:22:47 - open HousePriceReader
2019-03-20 12:22:47 - open Statistics
2019-03-20 12:22:47 - open XPlot.Plotly
2019-03-20 12:22:47 - let priceFilter:HousePriceInfo -> bool =
2019-03-20 12:22:47 -     fun h -> h.Date.Year=2016 && 
2019-03-20 12:22:47 -                 (h.TownCity.ToLower()="london"
2019-03-20 12:22:47 -                     || h.TownCity.ToLower()="manchester"
2019-03-20 12:22:47 -                     || h.TownCity.ToLower()="birmingham"
2019-03-20 12:22:47 -                     || h.TownCity.ToLower()="oxford"
2019-03-20 12:22:47 -                     || h.TownCity.ToLower()="cambridge")
2019-03-20 12:22:47 -                     
2019-03-20 12:22:47 - let boxGrouper:HousePriceInfo -> string =
2019-03-20 12:22:47 -     fun h -> h.TownCity.ToLower()
2019-03-20 12:22:47 - let ntiles:int=5
2019-03-20 12:22:47 - //type CityPrices
2019-03-20 12:22:47 - let cityValues = 
2019-03-20 12:22:47 -     SomeTransactions(priceFilter)
2019-03-20 12:22:47 -         |> Seq.groupBy (fun (p,h) -> boxGrouper(h))
2019-03-20 12:22:47 -         |> Seq.map (fun (k,v) ->  (k, v |> Seq.map (fun (p,h) -> float h.Price) |> Quantiles(4)))
2019-03-20 12:22:47 -         |> Seq.sortByDescending (fun (c,q) -> q.[ntiles/2])
2019-03-20 12:22:47 - type cityQTable = {City:string;q0:float;q1:float;q2:float;q3:float;q4:float}
2019-03-20 12:22:47 - cityValues
2019-03-20 12:22:47 -     |> Seq.map(fun (c,q) -> {City=c;q0=q.[0];q1=q.[1];q2=q.[2];q3=q.[3];q4=q.[4]})
2019-03-20 12:22:47 -     |> Util.Table
2019-03-20 12:22:47 - cityValues
2019-03-20 12:22:47 -     |> Seq.map(fun (c,q) -> Box(y=q, name=c))
2019-03-20 12:22:47 -     |> Chart.Plot
2019-03-20 12:26:17 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2019-03-20 12:26:17 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-03-20 12:26:17 - For help type #help;;
2019-03-20 12:26:17 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2019-03-20 12:26:17 -   seq []
2019-03-20 12:26:17 - --> Added 'D:\Applications\IfSharp.v3.0.0' to library include path
2019-03-20 12:26:17 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-03-20 12:26:17 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\NetMQ.dll' (file may be locked by F# Interactive process)
2019-03-20 12:32:58 - #load "Paket.fsx"
2019-03-20 12:32:58 - Paket.Package [
2019-03-20 12:32:58 -     "MathNet.Numerics"
2019-03-20 12:32:58 -     "MathNet.Numerics.FSharp"
2019-03-20 12:32:58 -     "XPlot.Plotly"
2019-03-20 12:32:58 -     ]
2019-03-20 12:32:58 - #load "Paket.Generated.Refs.fsx"
2019-03-20 12:32:58 - #load "XPlot.Plotly.fsx"
2019-03-20 12:32:58 - #load ".\DataAccess.fs"
2019-03-20 12:32:58 - #load ".\Statistics.fs"
2019-03-20 12:32:58 - #load ".\PGraphs.fs"
2019-03-20 12:32:58 - #load ".\Analyses.fs"
2019-03-20 12:33:07 - Possible incorrect indentation: this token is offside of context started at position (53:33). Try indenting this token further or using standard formatting conventions.
2019-03-20 12:33:07 - Possible incorrect indentation: this token is offside of context started at position (53:33). Try indenting this token further or using standard formatting conventions.
2019-03-20 12:33:07 - This value is not a function and cannot be applied.
2019-03-20 12:33:07 - The value or constructor 'ntiles' is not defined. Maybe you want one of the following:
2019-03-20 12:33:07 -    Quantiles
2019-03-20 12:33:07 - The value or constructor 'Box' is not defined. Maybe you want one of the following:
2019-03-20 12:33:07 -    box
2019-03-20 12:33:07 -    unbox
2019-03-20 12:33:07 - The value, namespace, type or module 'Chart' is not defined. Maybe you want one of the following:
2019-03-20 12:33:07 -    Char
2019-03-20 12:33:07 -    char
2019-03-20 12:33:07 - The value, namespace, type or module 'Chart' is not defined. Maybe you want one of the following:
2019-03-20 12:33:07 -    Char
2019-03-20 12:33:07 -    char
2019-03-20 12:36:21 - #load "Paket.fsx"
2019-03-20 12:36:21 - Paket.Package [
2019-03-20 12:36:21 -     "MathNet.Numerics"
2019-03-20 12:36:21 -     "MathNet.Numerics.FSharp"
2019-03-20 12:36:21 -     "XPlot.Plotly"
2019-03-20 12:36:21 -     ]
2019-03-20 12:36:21 - #load "Paket.Generated.Refs.fsx"
2019-03-20 12:36:21 - #load "XPlot.Plotly.fsx"
2019-03-20 12:36:21 - #load ".\DataAccess.fs"
2019-03-20 12:36:21 - #load ".\Statistics.fs"
2019-03-20 12:36:21 - #load ".\PGraphs.fs"
2019-03-20 12:36:21 - #load ".\Analyses.fs"
2019-03-20 12:36:28 - Possible incorrect indentation: this token is offside of context started at position (49:33). Try indenting this token further or using standard formatting conventions.
2019-03-20 12:36:28 - Possible incorrect indentation: this token is offside of context started at position (49:33). Try indenting this token further or using standard formatting conventions.
2019-03-20 12:36:28 - The type 'Microsoft.FSharp.Collections.seq<_>' expects 1 type argument(s) but is given 2
2019-03-20 12:37:05 - #load "Paket.fsx"
2019-03-20 12:37:05 - Paket.Package [
2019-03-20 12:37:05 -     "MathNet.Numerics"
2019-03-20 12:37:05 -     "MathNet.Numerics.FSharp"
2019-03-20 12:37:05 -     "XPlot.Plotly"
2019-03-20 12:37:05 -     ]
2019-03-20 12:37:05 - #load "Paket.Generated.Refs.fsx"
2019-03-20 12:37:05 - #load "XPlot.Plotly.fsx"
2019-03-20 12:37:05 - #load ".\DataAccess.fs"
2019-03-20 12:37:05 - #load ".\Statistics.fs"
2019-03-20 12:37:05 - #load ".\PGraphs.fs"
2019-03-20 12:37:05 - #load ".\Analyses.fs"
2019-03-20 12:37:12 - Unexpected symbol '>' in type arguments
2019-03-20 12:37:12 - Expected type argument or static argument
2019-03-20 12:37:12 - Unexpected start of structured construct in type arguments. Expected ',' or other token.
2019-03-20 12:37:12 - Expected type argument or static argument
2019-03-20 12:37:12 - Unexpected symbol '->' in binding. Expected '=' or other token.
2019-03-20 12:37:12 - Possible incorrect indentation: this token is offside of context started at position (49:33). Try indenting this token further or using standard formatting conventions.
2019-03-20 12:37:12 - Possible incorrect indentation: this token is offside of context started at position (49:33). Try indenting this token further or using standard formatting conventions.
2019-03-20 12:37:41 - #load "Paket.fsx"
2019-03-20 12:37:41 - Paket.Package [
2019-03-20 12:37:41 -     "MathNet.Numerics"
2019-03-20 12:37:41 -     "MathNet.Numerics.FSharp"
2019-03-20 12:37:41 -     "XPlot.Plotly"
2019-03-20 12:37:41 -     ]
2019-03-20 12:37:41 - #load "Paket.Generated.Refs.fsx"
2019-03-20 12:37:41 - #load "XPlot.Plotly.fsx"
2019-03-20 12:37:41 - #load ".\DataAccess.fs"
2019-03-20 12:37:41 - #load ".\Statistics.fs"
2019-03-20 12:37:41 - #load ".\PGraphs.fs"
2019-03-20 12:37:41 - #load ".\Analyses.fs"
2019-03-20 12:37:46 - Possible incorrect indentation: this token is offside of context started at position (49:33). Try indenting this token further or using standard formatting conventions.
2019-03-20 12:37:46 - Possible incorrect indentation: this token is offside of context started at position (49:33). Try indenting this token further or using standard formatting conventions.
2019-03-20 12:37:46 - This value is not a function and cannot be applied.
2019-03-20 12:37:46 - Type mismatch. Expecting a
2019-03-20 12:37:46 -     'seq<obj * float []> -> 'a'    
2019-03-20 12:37:46 - but given a
2019-03-20 12:37:46 -     'string -> seq<string * float []> -> XPlot.Plotly.PlotlyChart'    
2019-03-20 12:37:46 - The type 'seq<obj * float []>' does not match the type 'string'
2019-03-20 12:37:46 - This expression was expected to have type
2019-03-20 12:37:46 -     'string'    
2019-03-20 12:37:46 - but here has type
2019-03-20 12:37:46 -     ''a * 'b'    
2019-03-20 12:37:46 - Type mismatch. Expecting a
2019-03-20 12:37:46 -     'seq<obj * float []> -> 'a'    
2019-03-20 12:37:46 - but given a
2019-03-20 12:37:46 -     'string -> seq<string * float []> -> XPlot.Plotly.PlotlyChart'    
2019-03-20 12:37:46 - The type 'seq<obj * float []>' does not match the type 'string'
2019-03-20 12:38:43 - #load "Paket.fsx"
2019-03-20 12:38:43 - Paket.Package [
2019-03-20 12:38:43 -     "MathNet.Numerics"
2019-03-20 12:38:43 -     "MathNet.Numerics.FSharp"
2019-03-20 12:38:43 -     "XPlot.Plotly"
2019-03-20 12:38:43 -     ]
2019-03-20 12:38:43 - #load "Paket.Generated.Refs.fsx"
2019-03-20 12:38:43 - #load "XPlot.Plotly.fsx"
2019-03-20 12:38:43 - #load ".\DataAccess.fs"
2019-03-20 12:38:43 - #load ".\Statistics.fs"
2019-03-20 12:38:43 - #load ".\PGraphs.fs"
2019-03-20 12:38:43 - #load ".\Analyses.fs"
2019-03-20 12:38:51 - Possible incorrect indentation: this token is offside of context started at position (49:33). Try indenting this token further or using standard formatting conventions.
2019-03-20 12:38:51 - Possible incorrect indentation: this token is offside of context started at position (49:33). Try indenting this token further or using standard formatting conventions.
2019-03-20 12:38:51 - This value is not a function and cannot be applied.
2019-03-20 12:38:51 - Type mismatch. Expecting a
2019-03-20 12:38:51 -     'seq<obj * float []> -> 'a'    
2019-03-20 12:38:51 - but given a
2019-03-20 12:38:51 -     'string -> seq<string * float array> -> XPlot.Plotly.PlotlyChart'    
2019-03-20 12:38:51 - The type 'seq<obj * float []>' does not match the type 'string'
2019-03-20 12:38:51 - This expression was expected to have type
2019-03-20 12:38:51 -     'string'    
2019-03-20 12:38:51 - but here has type
2019-03-20 12:38:51 -     ''a * 'b'    
2019-03-20 12:38:51 - Type mismatch. Expecting a
2019-03-20 12:38:51 -     'seq<obj * float []> -> 'a'    
2019-03-20 12:38:51 - but given a
2019-03-20 12:38:51 -     'string -> seq<string * float array> -> XPlot.Plotly.PlotlyChart'    
2019-03-20 12:38:51 - The type 'seq<obj * float []>' does not match the type 'string'
2019-03-20 12:40:11 - #load "Paket.fsx"
2019-03-20 12:40:11 - Paket.Package [
2019-03-20 12:40:11 -     "MathNet.Numerics"
2019-03-20 12:40:11 -     "MathNet.Numerics.FSharp"
2019-03-20 12:40:11 -     "XPlot.Plotly"
2019-03-20 12:40:11 -     ]
2019-03-20 12:40:11 - #load "Paket.Generated.Refs.fsx"
2019-03-20 12:40:11 - #load "XPlot.Plotly.fsx"
2019-03-20 12:40:11 - #load ".\DataAccess.fs"
2019-03-20 12:40:11 - #load ".\Statistics.fs"
2019-03-20 12:40:11 - #load ".\PGraphs.fs"
2019-03-20 12:40:11 - #load ".\Analyses.fs"
2019-03-20 12:40:19 - This value is not a function and cannot be applied.
2019-03-20 12:40:19 - Type mismatch. Expecting a
2019-03-20 12:40:19 -     'seq<obj * float []> -> 'a'    
2019-03-20 12:40:19 - but given a
2019-03-20 12:40:19 -     'string -> seq<string * float array> -> XPlot.Plotly.PlotlyChart'    
2019-03-20 12:40:19 - The type 'seq<obj * float []>' does not match the type 'string'
2019-03-20 12:40:19 - This expression was expected to have type
2019-03-20 12:40:19 -     'string'    
2019-03-20 12:40:19 - but here has type
2019-03-20 12:40:19 -     ''a * 'b'    
2019-03-20 12:40:19 - Type mismatch. Expecting a
2019-03-20 12:40:19 -     'seq<obj * float []> -> 'a'    
2019-03-20 12:40:19 - but given a
2019-03-20 12:40:19 -     'string -> seq<string * float array> -> XPlot.Plotly.PlotlyChart'    
2019-03-20 12:40:19 - The type 'seq<obj * float []>' does not match the type 'string'
2019-03-20 12:40:55 - #load "Paket.fsx"
2019-03-20 12:40:55 - Paket.Package [
2019-03-20 12:40:55 -     "MathNet.Numerics"
2019-03-20 12:40:55 -     "MathNet.Numerics.FSharp"
2019-03-20 12:40:55 -     "XPlot.Plotly"
2019-03-20 12:40:55 -     ]
2019-03-20 12:40:55 - #load "Paket.Generated.Refs.fsx"
2019-03-20 12:40:55 - #load "XPlot.Plotly.fsx"
2019-03-20 12:40:55 - #load ".\DataAccess.fs"
2019-03-20 12:40:55 - #load ".\Statistics.fs"
2019-03-20 12:40:55 - #load ".\PGraphs.fs"
2019-03-20 12:40:55 - #load ".\Analyses.fs"
2019-03-20 12:41:04 - This value is not a function and cannot be applied.
2019-03-20 12:42:12 - #load "Paket.fsx"
2019-03-20 12:42:12 - Paket.Package [
2019-03-20 12:42:12 -     "MathNet.Numerics"
2019-03-20 12:42:12 -     "MathNet.Numerics.FSharp"
2019-03-20 12:42:12 -     "XPlot.Plotly"
2019-03-20 12:42:12 -     ]
2019-03-20 12:42:12 - #load "Paket.Generated.Refs.fsx"
2019-03-20 12:42:12 - #load "XPlot.Plotly.fsx"
2019-03-20 12:42:12 - #load ".\DataAccess.fs"
2019-03-20 12:42:12 - #load ".\Statistics.fs"
2019-03-20 12:42:12 - #load ".\PGraphs.fs"
2019-03-20 12:42:12 - #load ".\Analyses.fs"
2019-03-20 12:42:37 - open System
2019-03-20 12:42:37 - open HousePriceAnalysis
2019-03-20 12:42:37 - open Statistics
2019-03-20 12:42:37 - open DataSet
2019-03-20 12:42:37 - open PGraphs
2019-03-20 12:42:40 - //DISTRIBUTION
2019-03-20 12:42:40 - Analyses.RawHousePriceMap(fun h -> h.Date.Year=2016)
2019-03-20 12:42:40 -     
2019-03-20 12:43:10 - Analyses.RawHousePriceMap(fun h -> h.Date.Year=2016 && 
2019-03-20 12:43:10 -                                     (h.TownCity.ToLower()="london"
2019-03-20 12:43:10 -                                         || h.TownCity.ToLower()="manchester"
2019-03-20 12:43:10 -                                         || h.TownCity.ToLower()="birmingham"
2019-03-20 12:43:10 -                                         || h.TownCity.ToLower()="oxford"
2019-03-20 12:43:10 -                                         || h.TownCity.ToLower()="cambridge"))
2019-03-20 12:43:24 - BoxPlotAnalysis(priceFilter=fun h -> h.Date.Year=2016 && 
2019-03-20 12:43:24 -                                         (h.TownCity.ToLower()="london"
2019-03-20 12:43:24 -                                             || h.TownCity.ToLower()="manchester"
2019-03-20 12:43:24 -                                             || h.TownCity.ToLower()="birmingham"
2019-03-20 12:43:24 -                                             || h.TownCity.ToLower()="oxford"
2019-03-20 12:43:24 -                                             || h.TownCity.ToLower()="cambridge"))
2019-03-20 12:43:24 -                 (boxGrouper=fun h -> h.TownCity.ToLower())
2019-03-20 12:43:24 - The value or constructor 'BoxPlotAnalysis' is not defined. Maybe you want one of the following:
2019-03-20 12:43:24 -    BoxPlot
2019-03-20 12:43:41 - AnalysesBoxPlotAnalysis(priceFilter=fun h -> h.Date.Year=2016 && 
2019-03-20 12:43:41 -                                         (h.TownCity.ToLower()="london"
2019-03-20 12:43:41 -                                             || h.TownCity.ToLower()="manchester"
2019-03-20 12:43:41 -                                             || h.TownCity.ToLower()="birmingham"
2019-03-20 12:43:41 -                                             || h.TownCity.ToLower()="oxford"
2019-03-20 12:43:41 -                                             || h.TownCity.ToLower()="cambridge"))
2019-03-20 12:43:41 -                         (boxGrouper=fun h -> h.TownCity.ToLower())
2019-03-20 12:43:41 - Possible incorrect indentation: this token is offside of context started at position (2:46). Try indenting this token further or using standard formatting conventions.
2019-03-20 12:43:41 - Possible incorrect indentation: this token is offside of context started at position (2:46). Try indenting this token further or using standard formatting conventions.
2019-03-20 12:43:41 - The value or constructor 'AnalysesBoxPlotAnalysis' is not defined. Maybe you want one of the following:
2019-03-20 12:43:41 -    Analyses
2019-03-20 12:43:52 - AnalysesBoxPlotAnalysis(priceFilter=fun h -> h.Date.Year=2016 && 
2019-03-20 12:43:52 -                                             (h.TownCity.ToLower()="london"
2019-03-20 12:43:52 -                                                 || h.TownCity.ToLower()="manchester"
2019-03-20 12:43:52 -                                                 || h.TownCity.ToLower()="birmingham"
2019-03-20 12:43:52 -                                                 || h.TownCity.ToLower()="oxford"
2019-03-20 12:43:52 -                                                 || h.TownCity.ToLower()="cambridge"))
2019-03-20 12:43:52 -                         (boxGrouper=fun h -> h.TownCity.ToLower())
2019-03-20 12:43:52 - Possible incorrect indentation: this token is offside of context started at position (2:46). Try indenting this token further or using standard formatting conventions.
2019-03-20 12:43:52 - Possible incorrect indentation: this token is offside of context started at position (2:46). Try indenting this token further or using standard formatting conventions.
2019-03-20 12:43:52 - The value or constructor 'AnalysesBoxPlotAnalysis' is not defined. Maybe you want one of the following:
2019-03-20 12:43:52 -    Analyses
2019-03-20 12:44:12 - Analyses.BoxPlotAnalysis(priceFilter=fun h -> h.Date.Year=2016 && 
2019-03-20 12:44:12 -                                             (h.TownCity.ToLower()="london"
2019-03-20 12:44:12 -                                                 || h.TownCity.ToLower()="manchester"
2019-03-20 12:44:12 -                                                 || h.TownCity.ToLower()="birmingham"
2019-03-20 12:44:12 -                                                 || h.TownCity.ToLower()="oxford"
2019-03-20 12:44:12 -                                                 || h.TownCity.ToLower()="cambridge"))
2019-03-20 12:44:12 -                         (boxGrouper=fun h -> h.TownCity.ToLower())
2019-03-20 12:44:12 - Possible incorrect indentation: this token is offside of context started at position (2:47). Try indenting this token further or using standard formatting conventions.
2019-03-20 12:44:12 - Possible incorrect indentation: this token is offside of context started at position (2:47). Try indenting this token further or using standard formatting conventions.
2019-03-20 12:44:12 - This expression was expected to have type
2019-03-20 12:44:12 -     'HousePriceReader.HousePriceInfo -> bool'    
2019-03-20 12:44:12 - but here has type
2019-03-20 12:44:12 -     'bool'    
2019-03-20 12:44:12 - The value or constructor 'priceFilter' is not defined.
2019-03-20 12:44:12 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-03-20 12:44:12 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-03-20 12:44:12 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-03-20 12:44:12 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-03-20 12:44:12 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-03-20 12:44:12 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-03-20 12:44:12 - This expression was expected to have type
2019-03-20 12:44:12 -     'HousePriceReader.HousePriceInfo -> bool'    
2019-03-20 12:44:12 - but here has type
2019-03-20 12:44:12 -     'bool'    
2019-03-20 12:44:12 - This expression was expected to have type
2019-03-20 12:44:12 -     'HousePriceReader.HousePriceInfo -> string'    
2019-03-20 12:44:12 - but here has type
2019-03-20 12:44:12 -     'bool'    
2019-03-20 12:44:12 - The value or constructor 'boxGrouper' is not defined.
2019-03-20 12:44:12 - Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.
2019-03-20 12:44:12 - This expression was expected to have type
2019-03-20 12:44:12 -     'HousePriceReader.HousePriceInfo -> string'    
2019-03-20 12:44:12 - but here has type
2019-03-20 12:44:12 -     'bool'    
2019-03-20 12:44:45 - Analyses.BoxPlotAnalysis(fun h -> h.Date.Year=2016 && 
2019-03-20 12:44:45 -                                             (h.TownCity.ToLower()="london"
2019-03-20 12:44:45 -                                                 || h.TownCity.ToLower()="manchester"
2019-03-20 12:44:45 -                                                 || h.TownCity.ToLower()="birmingham"
2019-03-20 12:44:45 -                                                 || h.TownCity.ToLower()="oxford"
2019-03-20 12:44:45 -                                                 || h.TownCity.ToLower()="cambridge"))
2019-03-20 12:44:45 -                         (fun h -> h.TownCity.ToLower())
2019-03-20 12:45:54 - Analyses.BoxPlotAnalysis(fun h -> h.Date.Year=2016)
2019-03-20 12:45:54 -                         (fun h -> h.TownCity.ToLower())
2019-03-20 12:48:52 - #load "Paket.fsx"
2019-03-20 12:48:52 - Paket.Package [
2019-03-20 12:48:52 -     "MathNet.Numerics"
2019-03-20 12:48:52 -     "MathNet.Numerics.FSharp"
2019-03-20 12:48:52 -     "XPlot.Plotly"
2019-03-20 12:48:52 -     ]
2019-03-20 12:48:52 - #load "Paket.Generated.Refs.fsx"
2019-03-20 12:48:52 - #load "XPlot.Plotly.fsx"
2019-03-20 12:48:52 - #load ".\DataAccess.fs"
2019-03-20 12:48:52 - #load ".\Statistics.fs"
2019-03-20 12:48:52 - #load ".\PGraphs.fs"
2019-03-20 12:48:52 - #load ".\Analyses.fs"
2019-03-20 12:48:59 - This expression was expected to have type
2019-03-20 12:48:59 -     'int'    
2019-03-20 12:48:59 - but here has type
2019-03-20 12:48:59 -     ''a * 'b'    
2019-03-20 12:48:59 - Type mismatch. Expecting a
2019-03-20 12:48:59 -     'seq<(int -> seq<float> -> float)> -> float []'    
2019-03-20 12:48:59 - but given a
2019-03-20 12:48:59 -     'seq<(int -> seq<float> -> float)> -> (int -> seq<float> -> float) []'    
2019-03-20 12:48:59 - The type 'float' does not match the type 'int -> seq<float> -> float'
2019-03-20 12:48:59 - This expression was expected to have type
2019-03-20 12:48:59 -     'int'    
2019-03-20 12:48:59 - but here has type
2019-03-20 12:48:59 -     ''a * 'b'    
2019-03-20 12:48:59 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-20 12:48:59 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-20 12:49:04 - shutdown request
2019-03-20 12:49:20 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2019-03-20 12:49:20 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-03-20 12:49:20 - For help type #help;;
2019-03-20 12:49:20 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2019-03-20 12:49:20 -   seq []
2019-03-20 12:49:20 - --> Added 'D:\Applications\IfSharp.v3.0.0' to library include path
2019-03-20 12:49:20 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-03-20 12:49:20 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\NetMQ.dll' (file may be locked by F# Interactive process)
2019-03-20 12:49:20 - #load "Paket.fsx"
2019-03-20 12:49:20 - Paket.Package [
2019-03-20 12:49:20 -     "MathNet.Numerics"
2019-03-20 12:49:20 -     "MathNet.Numerics.FSharp"
2019-03-20 12:49:20 -     "XPlot.Plotly"
2019-03-20 12:49:20 -     ]
2019-03-20 12:49:20 - #load "Paket.Generated.Refs.fsx"
2019-03-20 12:49:20 - #load "XPlot.Plotly.fsx"
2019-03-20 12:49:20 - #load ".\DataAccess.fs"
2019-03-20 12:49:20 - #load ".\Statistics.fs"
2019-03-20 12:49:20 - #load ".\PGraphs.fs"
2019-03-20 12:49:20 - #load ".\Analyses.fs"
2019-03-20 12:49:38 - open System
2019-03-20 12:49:38 - open HousePriceAnalysis
2019-03-20 12:49:38 - open Statistics
2019-03-20 12:49:38 - open DataSet
2019-03-20 12:49:38 - open PGraphs
2019-03-20 12:49:39 - //DISTRIBUTION
2019-03-20 12:49:39 - Analyses.RawHousePriceMap(fun h -> h.Date.Year=2016)
2019-03-20 12:49:39 -     
2019-03-20 12:50:00 - Analyses.RawHousePriceMap(fun h -> h.Date.Year=2016 && 
2019-03-20 12:50:00 -                                     (h.TownCity.ToLower()="london"
2019-03-20 12:50:00 -                                         || h.TownCity.ToLower()="manchester"
2019-03-20 12:50:00 -                                         || h.TownCity.ToLower()="birmingham"
2019-03-20 12:50:00 -                                         || h.TownCity.ToLower()="oxford"
2019-03-20 12:50:00 -                                         || h.TownCity.ToLower()="cambridge"))
2019-03-20 12:50:01 - Analyses.BoxPlotAnalysis(fun h -> h.Date.Year=2016 && 
2019-03-20 12:50:01 -                                             (h.TownCity.ToLower()="london"
2019-03-20 12:50:01 -                                                 || h.TownCity.ToLower()="manchester"
2019-03-20 12:50:01 -                                                 || h.TownCity.ToLower()="birmingham"
2019-03-20 12:50:01 -                                                 || h.TownCity.ToLower()="oxford"
2019-03-20 12:50:01 -                                                 || h.TownCity.ToLower()="cambridge"))
2019-03-20 12:50:01 -                         (fun h -> h.TownCity.ToLower())
2019-03-20 12:50:01 - Expression evaluation failed: tried to take The input sequence has an insufficient number of elements. 5 past the end of the seq
2019-03-20 12:50:01 - InvalidOperationExceptiontried to take The input sequence has an insufficient number of elements. 5 past the end of the seq
2019-03-20 12:50:01 -    at Microsoft.FSharp.Collections.SeqModule.Take@683.GenerateNext(IEnumerable`1& next)
2019-03-20 12:50:01 -    at Microsoft.FSharp.Core.CompilerServices.GeneratedSequenceBase`1.MoveNextImpl()
2019-03-20 12:50:01 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& curr)
2019-03-20 12:50:01 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2019-03-20 12:50:01 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.map@74.DoMoveNext(b& curr)
2019-03-20 12:50:01 -    at Microsoft.FSharp.Collections.Internal.IEnumerator.MapEnumerator`1.System-Collections-IEnumerator-MoveNext()
2019-03-20 12:50:01 -    at Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.SerializeList(JsonWriter writer, IEnumerable values, JsonArrayContract contract, JsonProperty member, JsonContainerContract collectionContract, JsonProperty containerProperty)
2019-03-20 12:50:01 -    at Newtonsoft.Json.Serialization.JsonSerializerInternalWriter.Serialize(JsonWriter jsonWriter, Object value, Type objectType)
2019-03-20 12:50:01 -    at Newtonsoft.Json.JsonSerializer.SerializeInternal(JsonWriter jsonWriter, Object value, Type objectType)
2019-03-20 12:50:01 -    at Newtonsoft.Json.JsonConvert.SerializeObjectInternal(Object value, Type type, JsonSerializer jsonSerializer)
2019-03-20 12:50:01 -    at XPlot.Plotly.PlotlyChart.serializeTraces[b](FSharpOption`1 names, IEnumerable`1 traces)
2019-03-20 12:50:01 -    at XPlot.Plotly.PlotlyChart.GetInlineHtml()
2019-03-20 12:50:01 -    at FSI_0007.XPlot.Plotly.clo@10.Invoke(PlotlyChart plot) in D:\Applications\IfSharp.v3.0.0\XPlot.Plotly.fsx:line 11
2019-03-20 12:50:01 -    at IfSharp.Kernel.IfSharpKernel.executeRequest(KernelMessage msg, ExecuteRequest content) in E:\dev\IfSharp\src\IfSharp.Kernel\Kernel.fs:line 370
2019-03-20 12:50:01 - Analyses.BoxPlotAnalysis(fun h -> h.Date.Year=2016 && h.)
2019-03-20 12:50:01 -                         (fun h -> h.TownCity.ToLower())
2019-03-20 12:50:01 - Missing qualification after '.'
2019-03-20 12:50:01 - This expression was expected to have type
2019-03-20 12:50:01 -     'bool'    
2019-03-20 12:50:01 - but here has type
2019-03-20 12:50:01 -     'HousePriceReader.HousePriceInfo'    
2019-03-20 13:00:45 - #load "Paket.fsx"
2019-03-20 13:00:45 - Paket.Package [
2019-03-20 13:00:45 -     "MathNet.Numerics"
2019-03-20 13:00:45 -     "MathNet.Numerics.FSharp"
2019-03-20 13:00:45 -     "XPlot.Plotly"
2019-03-20 13:00:45 -     ]
2019-03-20 13:00:45 - #load "Paket.Generated.Refs.fsx"
2019-03-20 13:00:45 - #load "XPlot.Plotly.fsx"
2019-03-20 13:00:45 - #load ".\DataAccess.fs"
2019-03-20 13:00:45 - #load ".\Statistics.fs"
2019-03-20 13:00:45 - #load ".\PGraphs.fs"
2019-03-20 13:00:45 - #load ".\Analyses.fs"
2019-03-20 13:00:49 - This expression was expected to have type
2019-03-20 13:00:49 -     'int'    
2019-03-20 13:00:49 - but here has type
2019-03-20 13:00:49 -     ''a * 'b'    
2019-03-20 13:00:49 - Type mismatch. Expecting a
2019-03-20 13:00:49 -     'seq<(int -> seq<float> -> float)> -> float []'    
2019-03-20 13:00:49 - but given a
2019-03-20 13:00:49 -     'seq<(int -> seq<float> -> float)> -> (int -> seq<float> -> float) []'    
2019-03-20 13:00:49 - The type 'float' does not match the type 'int -> seq<float> -> float'
2019-03-20 13:00:49 - This expression was expected to have type
2019-03-20 13:00:49 -     'int'    
2019-03-20 13:00:49 - but here has type
2019-03-20 13:00:49 -     ''a * 'b'    
2019-03-20 13:00:49 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-20 13:00:49 - Expecting a type supporting the operator '-' but given a function type. You may be missing an argument to a function.
2019-03-20 13:01:11 - shutdown request
2019-03-20 13:01:18 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2019-03-20 13:01:19 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-03-20 13:01:19 - For help type #help;;
2019-03-20 13:01:19 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2019-03-20 13:01:19 -   seq []
2019-03-20 13:01:19 - --> Added 'D:\Applications\IfSharp.v3.0.0' to library include path
2019-03-20 13:01:19 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-03-20 13:01:19 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\NetMQ.dll' (file may be locked by F# Interactive process)
2019-03-20 13:01:19 - #load "Paket.fsx"
2019-03-20 13:01:19 - Paket.Package [
2019-03-20 13:01:19 -     "MathNet.Numerics"
2019-03-20 13:01:19 -     "MathNet.Numerics.FSharp"
2019-03-20 13:01:19 -     "XPlot.Plotly"
2019-03-20 13:01:19 -     ]
2019-03-20 13:01:19 - #load "Paket.Generated.Refs.fsx"
2019-03-20 13:01:19 - #load "XPlot.Plotly.fsx"
2019-03-20 13:01:19 - #load ".\DataAccess.fs"
2019-03-20 13:01:19 - #load ".\Statistics.fs"
2019-03-20 13:01:19 - #load ".\PGraphs.fs"
2019-03-20 13:01:19 - #load ".\Analyses.fs"
2019-03-20 13:01:33 - The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.
2019-03-20 13:01:33 - Incomplete structured construct at or before this point in binding
2019-03-20 13:01:33 - open System
2019-03-20 13:01:33 - open HousePriceAnalysis
2019-03-20 13:01:33 - open Statistics
2019-03-20 13:01:33 - open DataSet
2019-03-20 13:01:33 - open PGraphs
2019-03-20 13:01:34 - The namespace or module 'HousePriceAnalysis' is not defined.
2019-03-20 13:01:34 - The namespace or module 'Statistics' is not defined.
2019-03-20 13:01:34 - The namespace or module 'DataSet' is not defined. Maybe you want one of the following:
2019-03-20 13:01:34 -    Data
2019-03-20 13:01:34 - The namespace or module 'PGraphs' is not defined.
2019-03-20 13:01:34 - //DISTRIBUTION
2019-03-20 13:01:34 - Analyses.RawHousePriceMap(fun h -> h.Date.Year=2016)
2019-03-20 13:01:34 -     
2019-03-20 13:01:34 - The value, namespace, type or module 'Analyses' is not defined.
2019-03-20 13:01:34 - Analyses.RawHousePriceMap(fun h -> h.Date.Year=2016 && 
2019-03-20 13:01:34 -                                     (h.TownCity.ToLower()="london"
2019-03-20 13:01:34 -                                         || h.TownCity.ToLower()="manchester"
2019-03-20 13:01:34 -                                         || h.TownCity.ToLower()="birmingham"
2019-03-20 13:01:34 -                                         || h.TownCity.ToLower()="oxford"
2019-03-20 13:01:34 -                                         || h.TownCity.ToLower()="cambridge"))
2019-03-20 13:01:34 - The value, namespace, type or module 'Analyses' is not defined.
2019-03-20 13:01:34 - Analyses.BoxPlotAnalysis(fun h -> h.Date.Year=2016 && 
2019-03-20 13:01:34 -                                             (h.TownCity.ToLower()="london"
2019-03-20 13:01:34 -                                                 || h.TownCity.ToLower()="manchester"
2019-03-20 13:01:34 -                                                 || h.TownCity.ToLower()="birmingham"
2019-03-20 13:01:34 -                                                 || h.TownCity.ToLower()="oxford"
2019-03-20 13:01:34 -                                                 || h.TownCity.ToLower()="cambridge"))
2019-03-20 13:01:34 -                         (fun h -> h.TownCity.ToLower())
2019-03-20 13:01:34 - The value, namespace, type or module 'Analyses' is not defined.
2019-03-20 13:01:34 - Analyses.BoxTableAnalysis(fun h -> h.Date.Year=2016 && h.)
2019-03-20 13:01:34 -                          (fun h -> h.TownCity.ToLower())
2019-03-20 13:01:34 - Missing qualification after '.'
2019-03-20 13:01:34 - The value, namespace, type or module 'Analyses' is not defined.
2019-03-20 13:04:43 - shutdown request
2019-03-20 13:05:02 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2019-03-20 13:05:02 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-03-20 13:05:02 - For help type #help;;
2019-03-20 13:05:02 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2019-03-20 13:05:02 -   seq []
2019-03-20 13:05:02 - --> Added 'D:\Applications\IfSharp.v3.0.0' to library include path
2019-03-20 13:05:02 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-03-20 13:05:02 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\NetMQ.dll' (file may be locked by F# Interactive process)
2019-03-20 13:05:02 - #load "Paket.fsx"
2019-03-20 13:05:02 - Paket.Package [
2019-03-20 13:05:02 -     "MathNet.Numerics"
2019-03-20 13:05:02 -     "MathNet.Numerics.FSharp"
2019-03-20 13:05:02 -     "XPlot.Plotly"
2019-03-20 13:05:02 -     ]
2019-03-20 13:05:02 - #load "Paket.Generated.Refs.fsx"
2019-03-20 13:05:02 - #load "XPlot.Plotly.fsx"
2019-03-20 13:05:02 - #load ".\DataAccess.fs"
2019-03-20 13:05:02 - #load ".\Statistics.fs"
2019-03-20 13:05:02 - #load ".\PGraphs.fs"
2019-03-20 13:05:02 - #load ".\Analyses.fs"
2019-03-20 13:05:12 - Incomplete structured construct at or before this point in binding
2019-03-20 13:05:12 - open System
2019-03-20 13:05:12 - open HousePriceAnalysis
2019-03-20 13:05:12 - open Statistics
2019-03-20 13:05:12 - open DataSet
2019-03-20 13:05:12 - open PGraphs
2019-03-20 13:05:12 - The namespace or module 'HousePriceAnalysis' is not defined.
2019-03-20 13:05:12 - The namespace or module 'Statistics' is not defined.
2019-03-20 13:05:12 - The namespace or module 'DataSet' is not defined. Maybe you want one of the following:
2019-03-20 13:05:12 -    Data
2019-03-20 13:05:12 - The namespace or module 'PGraphs' is not defined.
2019-03-20 13:05:12 - //DISTRIBUTION
2019-03-20 13:05:12 - Analyses.RawHousePriceMap(fun h -> h.Date.Year=2016)
2019-03-20 13:05:12 -     
2019-03-20 13:05:12 - The value, namespace, type or module 'Analyses' is not defined.
2019-03-20 13:05:12 - Analyses.RawHousePriceMap(fun h -> h.Date.Year=2016 && 
2019-03-20 13:05:12 -                                     (h.TownCity.ToLower()="london"
2019-03-20 13:05:12 -                                         || h.TownCity.ToLower()="manchester"
2019-03-20 13:05:12 -                                         || h.TownCity.ToLower()="birmingham"
2019-03-20 13:05:12 -                                         || h.TownCity.ToLower()="oxford"
2019-03-20 13:05:12 -                                         || h.TownCity.ToLower()="cambridge"))
2019-03-20 13:05:12 - The value, namespace, type or module 'Analyses' is not defined.
2019-03-20 13:05:12 - Analyses.BoxPlotAnalysis(fun h -> h.Date.Year=2016 && 
2019-03-20 13:05:12 -                                             (h.TownCity.ToLower()="london"
2019-03-20 13:05:12 -                                                 || h.TownCity.ToLower()="manchester"
2019-03-20 13:05:12 -                                                 || h.TownCity.ToLower()="birmingham"
2019-03-20 13:05:12 -                                                 || h.TownCity.ToLower()="oxford"
2019-03-20 13:05:12 -                                                 || h.TownCity.ToLower()="cambridge"))
2019-03-20 13:05:12 -                         (fun h -> h.TownCity.ToLower())
2019-03-20 13:05:12 - The value, namespace, type or module 'Analyses' is not defined.
2019-03-20 13:05:12 - Analyses.BoxTableAnalysis(fun h -> h.Date.Year=2016 && h.)
2019-03-20 13:05:12 -                          (fun h -> h.TownCity.ToLower())
2019-03-20 13:05:12 - Missing qualification after '.'
2019-03-20 13:05:12 - The value, namespace, type or module 'Analyses' is not defined.
2019-03-20 13:07:26 - shutdown request
2019-03-20 13:07:42 - Microsoft (R) F# Interactive version 10.1.0 for F# 4.1
2019-03-20 13:07:42 - Copyright (c) Microsoft Corporation. All Rights Reserved.
2019-03-20 13:07:42 - For help type #help;;
2019-03-20 13:07:42 - > val it : ResizeArray<System.Type * (obj -> seq<string * string> * string)> =
2019-03-20 13:07:42 -   seq []
2019-03-20 13:07:42 - --> Added 'D:\Applications\IfSharp.v3.0.0' to library include path
2019-03-20 13:07:42 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\IfSharp.Kernel.dll' (file may be locked by F# Interactive process)
2019-03-20 13:07:42 - --> Referenced 'D:\Applications\IfSharp.v3.0.0\NetMQ.dll' (file may be locked by F# Interactive process)
2019-03-20 13:07:43 - #load "Paket.fsx"
2019-03-20 13:07:43 - Paket.Package [
2019-03-20 13:07:43 -     "MathNet.Numerics"
2019-03-20 13:07:43 -     "MathNet.Numerics.FSharp"
2019-03-20 13:07:43 -     "XPlot.Plotly"
2019-03-20 13:07:43 -     ]
2019-03-20 13:07:43 - #load "Paket.Generated.Refs.fsx"
2019-03-20 13:07:43 - #load "XPlot.Plotly.fsx"
2019-03-20 13:07:43 - #load ".\DataAccess.fs"
2019-03-20 13:07:43 - #load ".\Statistics.fs"
2019-03-20 13:07:43 - #load ".\PGraphs.fs"
2019-03-20 13:07:43 - #load ".\Analyses.fs"
2019-03-20 13:08:00 - open System
2019-03-20 13:08:00 - open HousePriceAnalysis
2019-03-20 13:08:00 - open Statistics
2019-03-20 13:08:00 - open DataSet
2019-03-20 13:08:00 - open PGraphs
2019-03-20 13:08:00 - //DISTRIBUTION
2019-03-20 13:08:00 - Analyses.RawHousePriceMap(fun h -> h.Date.Year=2016)
2019-03-20 13:08:00 -     
2019-03-20 13:08:23 - Analyses.RawHousePriceMap(fun h -> h.Date.Year=2016 && 
2019-03-20 13:08:23 -                                     (h.TownCity.ToLower()="london"
2019-03-20 13:08:23 -                                         || h.TownCity.ToLower()="manchester"
2019-03-20 13:08:23 -                                         || h.TownCity.ToLower()="birmingham"
2019-03-20 13:08:23 -                                         || h.TownCity.ToLower()="oxford"
2019-03-20 13:08:23 -                                         || h.TownCity.ToLower()="cambridge"))
2019-03-20 13:08:25 - Analyses.BoxPlotAnalysis(fun h -> h.Date.Year=2016 && 
2019-03-20 13:08:25 -                                             (h.TownCity.ToLower()="london"
2019-03-20 13:08:25 -                                                 || h.TownCity.ToLower()="manchester"
2019-03-20 13:08:25 -                                                 || h.TownCity.ToLower()="birmingham"
2019-03-20 13:08:25 -                                                 || h.TownCity.ToLower()="oxford"
2019-03-20 13:08:25 -                                                 || h.TownCity.ToLower()="cambridge"))
2019-03-20 13:08:25 -                         (fun h -> h.TownCity.ToLower())
2019-03-20 13:08:26 - Analyses.BoxTableAnalysis(fun h -> h.Date.Year=2016 && h.)
2019-03-20 13:08:26 -                          (fun h -> h.TownCity.ToLower())
2019-03-20 13:08:26 - Missing qualification after '.'
2019-03-20 13:08:26 - This expression was expected to have type
2019-03-20 13:08:26 -     'bool'    
2019-03-20 13:08:26 - but here has type
2019-03-20 13:08:26 -     'HousePriceReader.HousePriceInfo'    
2019-03-20 13:09:09 - Analyses.BoxTableAnalysis(fun h -> h.Date.Year=2016)
2019-03-20 13:09:09 -                          (fun h -> h.TownCity.ToLower())
2019-03-20 13:09:47 - Analyses.BoxAnalysis(fun h -> h.Date.Year=2016)(fun h -> h.TownCity.ToLower())
2019-03-20 13:09:47 -     |> Seq.Take(10)
2019-03-20 13:09:47 - The value, constructor, namespace or type 'Take' is not defined. Maybe you want one of the following:
2019-03-20 13:09:47 -    take
2019-03-20 13:09:47 -    takeWhile
2019-03-20 13:09:51 - Analyses.BoxAnalysis(fun h -> h.Date.Year=2016)(fun h -> h.TownCity.ToLower())
2019-03-20 13:09:51 -     |> Seq.take(10)
2019-03-20 13:10:12 - Analyses.BoxAnalysis(fun h -> h.Date.Year=2016)(fun h -> h.TownCity.ToLower())
2019-03-20 13:10:12 -     |> Seq.take(10)
2019-03-20 13:10:12 -     |> BoxPlot
2019-03-20 13:10:12 - Type mismatch. Expecting a
2019-03-20 13:10:12 -     'seq<string * float []> -> obj'    
2019-03-20 13:10:12 - but given a
2019-03-20 13:10:12 -     'string -> string -> seq<string * float array> -> XPlot.Plotly.PlotlyChart'    
2019-03-20 13:10:12 - The type 'seq<string * float []>' does not match the type 'string'
2019-03-20 13:12:39 - Analyses.BoxAnalysis(fun h -> h.Date.Year=2016)(fun h -> h.TownCity.ToLower())
2019-03-20 13:12:39 -     |> Seq.take(10)
2019-03-20 13:12:39 -     |> BoxPlot("Most Expensive UK Towns")("House Price (£)")
2019-03-20 13:13:22 - Analyses.BoxAnalysis(fun h -> h.Date.Year=2016)(fun h -> h.TownCity.ToLower())
2019-03-20 13:13:22 -     |> Seq.sortBy(fun (c,q) -> q.[2])
2019-03-20 13:13:22 -     |> Seq.take(10)
2019-03-20 13:13:22 -     |> BoxPlot("Most Expensive UK Towns")("House Price (£)")
2019-03-20 13:14:45 - Analyses.BoxAnalysis(fun h -> h.Date.Year=2016)(fun h -> h.TownCity.ToLower())
2019-03-20 13:14:45 -     |> Seq.sortBy(fun (c,q) -> q.[2])
2019-03-20 13:14:45 -     |> Seq.take(10)
2019-03-20 13:14:45 -     |> BoxPlot("Least Expensive UK Towns")("House Price (£)")
